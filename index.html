<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 래랑가로스</title>
    <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js" xintegrity="sha384-y3tIif2B4242xI/mS8d43/p/a1uBoL3w7sL2rS4z0nBjwA/2/g8L/DTrb1JScC4k" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 15px; transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1100px; margin: 0 auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; font-weight: 900; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding-top: 20px; margin-bottom: 2rem; letter-spacing: -2px; text-shadow: 2px 2px 10px var(--shadow-color); }
        .section { background: var(--surface-color); padding: 20px; border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 2.5rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 1.8rem; font-weight: 700; color: var(--primary-color); margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        details { margin-bottom: 1rem; border-radius: 8px; overflow: hidden; border: 1px solid var(--border-color); }
        details summary { background: linear-gradient(135deg, #2a2a2a, #222222); padding: 12px 15px; cursor: pointer; font-size: 1.1rem; font-weight: 700; color: var(--secondary-color); outline: none; transition: background 0.3s ease; }
        html[data-theme="light"] details summary { background: linear-gradient(135deg, #f9f9f9, #f1f1f1); color: var(--text-color); }
        details[open] summary { background: var(--primary-color); color: var(--bg-color); }
        html[data-theme="light"] details[open] summary { color: var(--secondary-color); }
        details.round-group > summary { background: var(--surface-color); border: 1px solid var(--primary-color); font-size: 1.3rem; font-weight: 900; color: var(--secondary-color); }
        html[data-theme="light"] details.round-group > summary { color: var(--text-color); }
        .round-group-content { padding: 15px 10px 5px 10px; background: rgba(0,0,0,0.1); border-top: 1px solid var(--border-color); }
        html[data-theme="light"] .round-group-content { background: rgba(0,0,0,0.02); }
        .table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        table { width: 100%; min-width: 600px; border-collapse: collapse; }
        th, td { padding: 12px 10px; text-align: center; border-bottom: 1px solid var(--border-color); font-size: 0.9rem; white-space: nowrap; }
        th { font-family: 'Poppins', sans-serif; background-color: rgba(0, 0, 0, 0.2); color: var(--primary-variant-color); font-weight: 700; }
        html[data-theme="light"] th { background-color: #F9FAFB; }
        #ranking-table tr:nth-child(-n+3) .rank-cell { font-weight: 900; color: var(--accent-gold); transform: scale(1.1); display: inline-block; }
        input[type="text"] { width: 100%; min-width: 80px; padding: 8px; background-color: #2c2c2c; border: 1px solid #444; border-radius: 6px; box-sizing: border-box; color: var(--text-color); font-family: 'Noto Sans KR', sans-serif; text-align: center; }
        html[data-theme="light"] input[type="text"] { background-color: #fdfdfd; border-color: #ddd; }
        input[type="text"].readonly { background-color: #252525; color: var(--text-secondary-color); font-weight: bold; }
        html[data-theme="light"] input[type="text"].readonly { background-color: #f0f0f0; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .btn { display: inline-block; padding: 12px 20px; background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1rem; border: none; text-align: center; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .update-btn { width: 100%; margin-top: 20px; padding: 15px; background: linear-gradient(135deg, var(--accent-gold), #F5B02E); color: var(--bg-color); border: none; border-radius: 8px; font-size: 1.2rem; font-weight: 900; cursor: pointer; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #333, #111); color: #fff; padding: 12px 25px; border-radius: 50px; box-shadow: 0 5px 15px var(--shadow-color); opacity: 0; transition: opacity 0.4s, transform 0.4s; font-weight: 700; z-index: 1000; }
        .toast.show { opacity: 1; }
        .championship-star { color: var(--accent-gold); text-shadow: 0 0 5px var(--accent-gold); font-size: 1.1rem; font-weight: 900; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1>2025 래랑가로스</h1>

        <div class="section">
            <h2>경기 일정</h2>
            <div id="schedule-container"></div>
            <button id="update-ranking" class="update-btn">순위 업데이트</button>
        </div>

        <div class="section">
            <h2>시즌 순위표</h2>
            <div class="table-wrapper">
                <table id="ranking-table">
                    <thead><tr><th>순위</th><th>선수</th><th>MMR</th><th>우승</th><th>승</th><th>패</th><th>게임득실</th><th>접전승률(%)</th><th>압도승률(%)</th><th>최고 파트너</th><th>최하 파트너</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="btn-group">
                <a href="dash.html" class="btn" id="dashboard-link">통계 대시보드</a>
                <button id="kakao-share-btn" class="btn">카카오톡 공유</button>
                <button id="download-csv" class="btn">CSV 다운로드</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
        
        const firebaseConfig = { apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", authDomain: "tennis-plan-jibung.firebaseapp.com", projectId: "tennis-plan-jibung", storageBucket: "tennis-plan-jibung.appspot.com", messagingSenderId: "491083537160", appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" };
        
        let db;
        try {
            db = getFirestore(initializeApp(firebaseConfig));
            // Kakao.init('YOUR_JAVASCRIPT_KEY');
        } catch (e) { console.error(e); }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function createScheduleRounds() {
            const container = document.getElementById('schedule-container');
            let roundsHtml = '';
            for (let group = 0; group < 6; group++) {
                const startRound = group * 10 + 1;
                const endRound = (group + 1) * 10;
                roundsHtml += `<details class="round-group"><summary>${startRound} ~ ${endRound}회차</summary><div class="round-group-content">`;
                for (let i = startRound; i <= endRound; i++) {
                    roundsHtml += `
                    <details>
                        <summary>${i}회차</summary>
                        <div class="table-wrapper">
                        <table class="schedule-table" data-round-id="${i}">
                            <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                            <tbody>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                            </tbody>
                        </table></div></details>`;
                }
                roundsHtml += `</div></details>`;
            }
            container.innerHTML = roundsHtml;
        }
        
        function createRankingRows() {
            const rankingBody = document.querySelector('#ranking-table tbody');
            let rowsHtml = '';
            for (let i = 1; i <= 30; i++) {
                rowsHtml += `
                <tr>
                    <td class="rank-cell">${i}</td><td><input type="text" placeholder="선수 ${i}" class="ranking-player"></td><td><input type="text" class="mmr readonly" readonly></td><td><span class="championship-star"></span></td><td><input type="text" class="wins readonly" readonly></td><td><input type="text" class="losses readonly" readonly></td><td><input type="text" class="game-diff readonly" readonly></td><td><input type="text" class="close-wins readonly" readonly></td><td><input type="text" class="dominant-wins readonly" readonly></td><td><input type="text" class="best-partner readonly" readonly></td><td><input type="text" class="worst-partner readonly" readonly></td>
                </tr>`;
            }
            rankingBody.innerHTML = rowsHtml;
        }
        
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('theme-toggle').textContent = theme === 'dark' ? '☀️' : '�';
            localStorage.setItem('theme', theme);
        }

        function shareOnKakao() { /* 이전 코드와 동일 */ }
        
        function downloadCSV() {
            let rankingCSV = '\uFEFF순위,선수,MMR,우승,승,패,게임득실,접전승률(%),압도승률(%),최고 파트너,최하 파트너\n';
            document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
                const player = row.querySelector('.ranking-player').value;
                if(player) {
                    const rank = row.cells[0].textContent;
                    const mmr = row.querySelector('.mmr').value;
                    const championships = row.querySelector('.championship-star')?.dataset.count || '0';
                    const wins = row.querySelector('.wins').value;
                    const losses = row.querySelector('.losses').value;
                    const gameDiff = row.querySelector('.game-diff').value;
                    const closeWins = row.querySelector('.close-wins').value;
                    const dominantWins = row.querySelector('.dominant-wins').value;
                    const bestPartner = row.querySelector('.best-partner').value;
                    const worstPartner = row.querySelector('.worst-partner').value;
                    rankingCSV += `${rank},"${player}",${mmr},${championships},${wins},${losses},${gameDiff},${closeWins},${dominantWins},"${bestPartner}","${worstPartner}"\n`;
                }
            });
            
            const blob = new Blob([rankingCSV], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'raelangaros_rankings.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function saveData() {
            if (!db) return showToast('DB 연결 실패');
            try {
                // Schedule Data
                const scheduleRows = document.querySelectorAll('.schedule-table tbody tr');
                const scheduleData = Array.from(scheduleRows).map(row => ({ player1: row.querySelector('.player1').value.trim(), player2: row.querySelector('.player2').value.trim(), player3: row.querySelector('.player3').value.trim(), player4: row.querySelector('.player4').value.trim(), score: row.querySelector('.score').value.trim() }));
                await setDoc(doc(db, 'league', 'data', 'schedule', 'v1'), { matches: scheduleData });

                // Ranking Data
                const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
                const rankingData = Array.from(rankingRows).map(row => ({ name: row.querySelector('.ranking-player').value.trim(), mmr: row.querySelector('.mmr').value || '0', championships: row.querySelector('.championship-star')?.dataset.count || '0', wins: row.querySelector('.wins').value || '0', losses: row.querySelector('.losses').value || '0', gameDiff: row.querySelector('.game-diff').value || '0', closeWins: row.querySelector('.close-wins').value || '', dominantWins: row.querySelector('.dominant-wins').value || '', bestPartner: row.querySelector('.best-partner').value || '-', worstPartner: row.querySelector('.worst-partner').value || '-' })).filter(player => player.name);
                await setDoc(doc(db, 'league', 'data', 'rankings', 'v1'), { players: rankingData });

                showToast('데이터가 자동 저장되었습니다.');
            } catch (e) { showToast(`저장 실패: ${e.message}`); }
        }

        async function loadData() {
            if (!db) return;
            try {
                const scheduleDoc = await getDoc(doc(db, 'league', 'data', 'schedule', 'v1'));
                if (scheduleDoc.exists()) {
                    const scheduleData = scheduleDoc.data().matches || [];
                    const scheduleRows = document.querySelectorAll('.schedule-table tbody tr');
                    scheduleData.forEach((match, index) => {
                        if (scheduleRows[index]) {
                            scheduleRows[index].querySelector('.player1').value = match.player1 || '';
                            scheduleRows[index].querySelector('.player2').value = match.player2 || '';
                            scheduleRows[index].querySelector('.player3').value = match.player3 || '';
                            scheduleRows[index].querySelector('.player4').value = match.player4 || '';
                            scheduleRows[index].querySelector('.score').value = match.score || '';
                        }
                    });
                }
                const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
                if (rankingDoc.exists()) {
                    const rankingData = rankingDoc.data().players || [];
                    const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
                    rankingRows.forEach((row, index) => {
                         const player = rankingData[index];
                         if (player) {
                            row.querySelector('.ranking-player').value = player.name || '';
                            row.querySelector('.mmr').value = player.mmr || '0';
                            const champStar = row.querySelector('.championship-star');
                            champStar.dataset.count = player.championships || '0';
                            champStar.textContent = '⭐'.repeat(parseInt(player.championships) || 0);
                            row.querySelector('.wins').value = player.wins || '0';
                            row.querySelector('.losses').value = player.losses || '0';
                            row.querySelector('.game-diff').value = player.gameDiff || '0';
                            row.querySelector('.close-wins').value = player.closeWins || '';
                            row.querySelector('.dominant-wins').value = player.dominantWins || '';
                            row.querySelector('.best-partner').value = player.bestPartner || '-';
                            row.querySelector('.worst-partner').value = player.worstPartner || '-';
                         }
                    });
                }
                 showToast("데이터를 성공적으로 불러왔습니다.");
            } catch(e) { showToast("데이터 로드 실패: " + e.message); }
        }
        
        async function updateRanking() {
            const players = {};
            const partnerStats = {};
            const rivalStats = {};
            const giantKillStats = {};
            const BASE_MMR = 1500;
            const K_FACTOR = 32;

            document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
                const name = row.querySelector('.ranking-player').value.trim();
                if (name) {
                    players[name] = { name, wins: 0, losses: 0, gameDiff: 0, mmr: BASE_MMR, championships: 0, closeWins: 0, closeSets: 0, dominantWins: 0, totalSets: 0 };
                    partnerStats[name] = {};
                }
            });

            const scheduleTables = document.querySelectorAll('.schedule-table');
            scheduleTables.forEach((table) => {
                const rows = table.querySelectorAll('tbody tr');
                let roundWins = {};
                rows.forEach(row => {
                    const p1 = row.querySelector('.player1').value.trim();
                    const p2 = row.querySelector('.player2').value.trim();
                    const p3 = row.querySelector('.player3').value.trim();
                    const p4 = row.querySelector('.player4').value.trim();
                    const score = row.querySelector('.score').value.trim();

                    if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;
                    const [score1, score2] = score.split('-').map(Number);
                    [p1,p2,p3,p4].forEach(p => { 
                        if(p && !players[p]) {
                            players[p] = { name: p, wins: 0, losses: 0, gameDiff: 0, mmr: BASE_MMR, championships: 0, closeWins: 0, closeSets: 0, dominantWins: 0, totalSets: 0 };
                            partnerStats[p] = {};
                        }
                    });
                    const updatePartnerStats = (player, partner, isWin, gameDiff) => {
                        if (!partnerStats[player][partner]) {
                            partnerStats[player][partner] = { wins: 0, losses: 0, gameDiffSum: 0, matches: 0 };
                        }
                        const stats = partnerStats[player][partner];
                        stats.matches++;
                        stats.gameDiffSum += gameDiff;
                        if (isWin) stats.wins++; else stats.losses++;
                    };
                    const team1MMR = (players[p1].mmr + players[p2].mmr) / 2;
                    const team2MMR = (players[p3].mmr + players[p4].mmr) / 2;
                    const mmrDiff = Math.abs(team1MMR - team2MMR);
                    const expected1 = 1 / (1 + Math.pow(10, (team2MMR - team1MMR) / 400));
                    const actual1 = score1 > score2 ? 1 : 0;
                    const mmrChange = K_FACTOR * (actual1 - expected1);
                    const updatePlayer = (name, isWinner, gameDiff, mmrChangeVal, isClose, isDominant) => {
                        players[name].totalSets++;
                        players[name].gameDiff += gameDiff;
                        players[name].mmr += mmrChangeVal;
                        if(isWinner) {
                            players[name].wins++;
                            if(!roundWins[name]) roundWins[name] = 0;
                            roundWins[name]++;
                        } else { players[name].losses++; }
                        if(isClose) {
                            players[name].closeSets++;
                            if(isWinner) players[name].closeWins++;
                        }
                        if(isDominant && isWinner) players[name].dominantWins++;
                    };
                    const isClose = Math.abs(score1 - score2) <= 2;
                    if (isClose) {
                        [p1, p2].forEach(player1 => {
                            [p3, p4].forEach(player2 => {
                                const key = [player1, player2].sort().join(' vs ');
                                rivalStats[key] = (rivalStats[key] || 0) + 1;
                            });
                        });
                    }
                    if (mmrDiff > 100) {
                        if (actual1 === 1 && team1MMR < team2MMR) { giantKillStats[p1] = (giantKillStats[p1] || 0) + 1; giantKillStats[p2] = (giantKillStats[p2] || 0) + 1; }
                        else if (actual1 === 0 && team2MMR < team1MMR) { giantKillStats[p3] = (giantKillStats[p3] || 0) + 1; giantKillStats[p4] = (giantKillStats[p4] || 0) + 1; }
                    }
                    const isDominant1 = score1 === 6 && score2 <= 1;
                    const isDominant2 = score2 === 6 && score1 <= 1;
                    updatePlayer(p1, actual1, score1 - score2, mmrChange, isClose, isDominant1);
                    updatePlayer(p2, actual1, score1 - score2, mmrChange, isClose, isDominant1);
                    updatePlayer(p3, 1-actual1, score2 - score1, -mmrChange, isClose, isDominant2);
                    updatePlayer(p4, 1-actual1, score2 - score1, -mmrChange, isClose, isDominant2);
                    if (actual1 > 0) {
                        updatePartnerStats(p1, p2, true, score1 - score2); updatePartnerStats(p2, p1, true, score1 - score2);
                        updatePartnerStats(p3, p4, false, score2 - score1); updatePartnerStats(p4, p3, false, score2 - score1);
                    } else {
                        updatePartnerStats(p1, p2, false, score1 - score2); updatePartnerStats(p2, p1, false, score1 - score2);
                        updatePartnerStats(p3, p4, true, score2 - score1); updatePartnerStats(p4, p3, true, score2 - score1);
                    }
                });
                Object.keys(roundWins).forEach(pName => { if (roundWins[pName] === 3 && players[pName]) { players[pName].championships++; } });
            });
            const sortedPlayers = Object.values(players).sort((a, b) => b.mmr - a.mmr);
            
            // --- START: Award Calculation & Saving ---
            const awards = {};
            if (sortedPlayers.length > 0) {
                const playedPlayers = sortedPlayers.filter(p => (p.wins + p.losses) > 0);
                if (playedPlayers.length > 0) {
                    const maxMmr = Math.max(...playedPlayers.map(p => p.mmr));
                    const minMmr = Math.min(...playedPlayers.map(p => p.mmr));
                    const maxGameDiff = Math.max(...playedPlayers.map(p => p.gameDiff));
                    const minGameDiff = Math.min(...playedPlayers.map(p => p.gameDiff));
                    const maxChamps = Math.max(...playedPlayers.map(p => p.championships));

                    sortedPlayers.forEach(p => {
                        if ((p.wins + p.losses) === 0) { p.mvpScore = 0; return; }
                        const normalize = (val, min, max) => (max - min) > 0 ? (val - min) / (max - min) : 0.5;
                        const mmrScore = normalize(p.mmr, minMmr, maxMmr) * 3.0;
                        const winRateScore = (p.wins / (p.wins + p.losses)) * 3.0;
                        const gameDiffScore = normalize(p.gameDiff, minGameDiff, maxGameDiff) * 2.0;
                        const champScore = (maxChamps > 0 ? p.championships / maxChamps : 0) * 2.0;
                        p.mvpScore = mmrScore + winRateScore + gameDiffScore + champScore;
                    });
                     awards.mvp = sortedPlayers.reduce((prev, curr) => (prev.mvpScore >= curr.mvpScore) ? prev : curr);
                }
                
                awards.formKing = sortedPlayers.reduce((prev, curr) => ((prev.totalSets > 0 ? prev.dominantWins / prev.totalSets : 0) >= (curr.totalSets > 0 ? curr.dominantWins / curr.totalSets : 0)) ? prev : curr);
                awards.victoryFairy = sortedPlayers.reduce((prev, curr) => (prev.championships >= curr.championships) ? prev : curr);
                awards.mostImproved = sortedPlayers.reduce((prev, curr) => ((prev.mmr - BASE_MMR) >= (curr.mmr - BASE_MMR)) ? prev : curr);
                awards.clutchKing = sortedPlayers.reduce((prev, curr) => ((prev.closeSets > 0 ? prev.closeWins / prev.closeSets : 0) >= (curr.closeSets > 0 ? curr.closeWins / curr.closeSets : 0)) ? prev : curr);
                awards.courtKiller = sortedPlayers.reduce((prev, curr) => (prev.gameDiff >= curr.gameDiff) ? prev : curr);

                let giantKillerName = '-', maxKills = 0;
                Object.keys(giantKillStats).forEach(name => { if(giantKillStats[name] > maxKills) { maxKills = giantKillStats[name]; giantKillerName = name; }});
                awards.giantKiller = { name: giantKillerName, value: maxKills };
                
                let rivalPair = '-', maxRivalMatches = 0;
                Object.keys(rivalStats).forEach(pair => { if(rivalStats[pair] > maxRivalMatches) { maxRivalMatches = rivalStats[pair]; rivalPair = pair; }});
                awards.rivalPair = { name: rivalPair, value: maxRivalMatches };
                
                let bestDoubles = { name: '-', wins: 0 };
                const pairs = {};
                for(const p1 in partnerStats) {
                    for(const p2 in partnerStats[p1]) {
                        if(p1 < p2) {
                            const key = `${p1} / ${p2}`;
                            if(!pairs[key]) pairs[key] = { wins: 0 };
                            pairs[key].wins += partnerStats[p1][p2].wins;
                        }
                    }
                }
                Object.keys(pairs).forEach(pairKey => { if(pairs[pairKey].wins > bestDoubles.wins) { bestDoubles = { name: pairKey, wins: pairs[pairKey].wins }; }});
                awards.bestDoubles = { name: bestDoubles.name, value: bestDoubles.wins };
                
                const awardsData = {
                    mvp: { name: awards.mvp?.name || '-', value: `${(awards.mvp?.mvpScore || 0).toFixed(1)}점` },
                    formKing: { name: awards.formKing?.name || '-', value: `${awards.formKing?.totalSets > 0 ? Math.round(awards.formKing.dominantWins / awards.formKing.totalSets * 100) : 0}%` },
                    victoryFairy: { name: awards.victoryFairy?.name || '-', value: `${awards.victoryFairy?.championships || 0}회` },
                    mostImproved: { name: awards.mostImproved?.name || '-', value: `+${Math.round(awards.mostImproved?.mmr - BASE_MMR) || 0}` },
                    clutchKing: { name: awards.clutchKing?.name || '-', value: `${awards.clutchKing?.closeSets > 0 ? Math.round(awards.clutchKing.closeWins / awards.clutchKing.closeSets * 100) : 0}%` },
                    courtKiller: { name: awards.courtKiller?.name || '-', value: `+${awards.courtKiller?.gameDiff || 0}` },
                    giantKiller: { name: awards.giantKiller.name, value: `${awards.giantKiller.value}회` },
                    rivalPair: { name: awards.rivalPair.name, value: `${awards.rivalPair.value}회` },
                    bestDoubles: { name: awards.bestDoubles.name, value: `${awards.bestDoubles.value}승` },
                };
                await setDoc(doc(db, 'league', 'data', 'awards', 'v1'), awardsData);
            }
            // --- END: Award Calculation & Saving ---

            const mmrSnapshot = { createdAt: serverTimestamp() };
            sortedPlayers.forEach(p => { mmrSnapshot[p.name.replace(/\./g, '_')] = Math.round(p.mmr); });
            if(Object.keys(mmrSnapshot).length > 1) {
                const historyRef = collection(db, 'league', 'data', 'mmrHistory');
                await addDoc(historyRef, mmrSnapshot);
            }
            const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
            rankingRows.forEach((row, index) => {
                const player = sortedPlayers[index];
                if (player) {
                    row.cells[0].textContent = index + 1;
                    row.querySelector('.ranking-player').value = player.name;
                    row.querySelector('.mmr').value = Math.round(player.mmr);
                    const champStar = row.querySelector('.championship-star');
                    champStar.dataset.count = player.championships;
                    champStar.textContent = '⭐'.repeat(player.championships);
                    row.querySelector('.wins').value = player.wins;
                    row.querySelector('.losses').value = player.losses;
                    row.querySelector('.game-diff').value = player.gameDiff;
                    row.querySelector('.close-wins').value = player.closeSets > 0 ? Math.round(player.closeWins / player.closeSets * 100) : 0;
                    row.querySelector('.dominant-wins').value = player.totalSets > 0 ? Math.round(player.dominantWins / player.totalSets * 100) : 0;
                    let bestPartner = { name: '-', score: -Infinity };
                    let worstPartner = { name: '-', score: Infinity };
                    if(partnerStats[player.name]){
                        for (const partnerName in partnerStats[player.name]) {
                            const stats = partnerStats[player.name][partnerName];
                            const winRate = stats.wins / stats.matches;
                            const avgGameDiff = stats.gameDiffSum / stats.matches;
                            const chemistryScore = (winRate * 70) + (avgGameDiff * 3);
                            if (chemistryScore > bestPartner.score) { bestPartner = { name: partnerName, score: chemistryScore }; }
                            if (chemistryScore < worstPartner.score) { worstPartner = { name: partnerName, score: chemistryScore }; }
                        }
                    }
                    row.querySelector('.best-partner').value = bestPartner.name;
                    row.querySelector('.worst-partner').value = worstPartner.name;
                } else {
                    row.cells[0].textContent = index + 1;
                    row.querySelectorAll('input:not([type=button])').forEach(input => input.value = '');
                    row.querySelector('.championship-star').textContent = '';
                }
            });
            await saveData();
            showToast('순위 업데이트 완료!');
        }
        
        function setupInputListeners() {
            document.querySelectorAll('#schedule-container input, #ranking-table .ranking-player').forEach(input => {
                input.addEventListener('change', saveData);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            applyTheme(localStorage.getItem('theme') || 'dark');
            createScheduleRounds();
            createRankingRows();
            if (db) {
                loadData();
                setupInputListeners();
            }
            document.getElementById('theme-toggle').addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
            document.getElementById('update-ranking').addEventListener('click', updateRanking);
            document.getElementById('kakao-share-btn').addEventListener('click', shareOnKakao);
            document.getElementById('download-csv').addEventListener('click', downloadCSV);
        });
    </script>
</body>
</html>
�