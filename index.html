<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 래랑가로스</title>
    <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js" integrity="sha384-y3tIif2B4242xI/mS8d43/p/a1uBoL3w7sL2rS4z0nBjwA/2/g8L/DTrb1JScC4k" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Poppins:wght@600;700&display=stylesheet" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFC107; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
            --spacing-sm: 8px; --spacing-md: 12px; --spacing-lg: 20px; --radius: 8px;
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: var(--spacing-md); transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1700px; margin: 0 auto; } /* PC 버전 좌우폭 유지 */
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; font-weight: 900; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding-top: var(--spacing-lg); margin-bottom: 2rem; letter-spacing: -2px; text-shadow: 2px 2px 10px var(--shadow-color); }
        .section { background: var(--surface-color); padding: var(--spacing-lg); border-radius: var(--radius); box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 2.5rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 1.8rem; font-weight: 700; color: var(--primary-color); margin-bottom: var(--spacing-sm); padding-bottom: var(--spacing-sm); border-bottom: 2px solid var(--border-color); }
        details { margin-bottom: 1rem; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border-color); }
        details summary { padding: var(--spacing-md) 15px; cursor: pointer; font-size: 1.1rem; font-weight: 700; outline: none; transition: background 0.3s ease, color 0.3s ease; background: linear-gradient(135deg, #2a2a2a, #222222); color: var(--secondary-color); }
        html[data-theme="light"] details summary { background: linear-gradient(135deg, #f9f9f9, #f1f1f1); color: var(--text-color); }
        details[open] > summary { background: var(--primary-color); color: var(--bg-color); }
        html[data-theme="light"] details[open] > summary { color: var(--secondary-color); }
        .round-group-content { padding: 15px 10px 5px 10px; background: rgba(0,0,0,0.1); border-top: 1px solid var(--border-color); }
        html[data-theme="light"] .round-group-content { background: rgba(0,0,0,0.02); }
        .table-wrapper { overflow-x: auto; overflow-y: auto; max-height: 70vh; max-width: 100%; -webkit-overflow-scrolling: touch; } /* 좌우 스크롤 강화 */
        table { width: 100%; min-width: 100%; border-collapse: collapse; }
        th, td { padding: var(--spacing-md) 4px; text-align: center; border-bottom: 1px solid var(--border-color); font-size: 0.9rem; white-space: nowrap; }
        #ranking-table thead th { position: sticky; top: 0; background: var(--surface-color); z-index: 10; }
        th { font-family: 'Poppins', sans-serif; background-color: rgba(0, 0, 0, 0.2); color: var(--primary-variant-color); font-weight: 700; }
        html[data-theme="light"] th { background-color: #F9FAFB; }
        .rank-cell { font-weight: 900; color: var(--accent-gold); text-shadow: 0 0 5px var(--shadow-color); position: relative; line-height: 1.2; }
        .streak-cell { font-size: 0.7rem; white-space: nowrap; margin-left: var(--spacing-sm); }
        .streak-win { color: #4CAF50; font-weight: bold; }
        .streak-loss { color: #F44336; font-weight: bold; }
        .streak-none { color: var(--text-secondary-color); }
        #ranking-table th:nth-child(2), #ranking-table td:nth-child(2) { position: sticky; left: 0; background: var(--surface-color); z-index: 1; }
        input[type="text"] { width: 100%; min-width: 70px; max-width: 100px; padding: var(--spacing-sm); background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; color: var(--text-color); font-family: 'Noto Sans KR', sans-serif; text-align: center; }
        input.ranking-player, input.mmr { min-width: 80px; max-width: 120px; }
        input.readonly { background-color: #252525; color: var(--text-secondary-color); font-weight: bold; }
        html[data-theme="light"] input.readonly { background-color: #f0f0f0; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: var(--spacing-lg); }
        .btn { display: inline-block; padding: var(--spacing-md) var(--spacing-lg); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: var(--radius); cursor: pointer; font-weight: 700; font-size: 1rem; border: none; text-align: center; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .update-btn { width: 100%; margin-top: var(--spacing-lg); padding: 15px; background: linear-gradient(135deg, var(--accent-gold), #F5B02E); color: var(--bg-color); border: none; border-radius: var(--radius); font-size: 1.2rem; font-weight: 900; cursor: pointer; }
        .toast { position: fixed; bottom: var(--spacing-lg); left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #333, #111); color: #fff; padding: var(--spacing-md) 25px; border-radius: 50px; box-shadow: 0 5px 15px var(--shadow-color); opacity: 0; transition: opacity 0.4s, transform 0.4s; font-weight: 700; z-index: 1000; }
        .toast.show { opacity: 1; }
        .championship-star { color: var(--accent-gold); text-shadow: 0 0 5px var(--shadow-color); font-size: 1.1rem; font-weight: 900; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .ranking-player[value$="*"] { color: var(--primary-variant-color); }
        .ranking-filter { display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md); }
        .filter-btn { padding: var(--spacing-sm) var(--spacing-md); background: var(--surface-color); border: 1px solid var(--border-color); border-radius: var(--radius); cursor: pointer; color: var(--text-color); font-weight: 700; }
        .filter-btn.active { background: var(--primary-color); color: var(--bg-color); }
        .toggle-btn { padding: var(--spacing-sm) var(--spacing-md); margin: var(--spacing-sm) auto; display: block; }
        tr.lower-rank { display: none; }
        tr.lower-rank.show { display: table-row; }
        @media screen and (max-width: 600px) {
            th, td { padding: 4px 2px; font-size: 0.7rem; }
            input[type="text"] { min-width: 70px; max-width: 100px; font-size: 0.7rem; }
            input.ranking-player, input.mmr { min-width: 60px; max-width: 90px; }
            input.best-partner { min-width: 200px; max-width: 225px; } /* 모바일 폭 유지 */
            .schedule-table td input.player1, .schedule-table td input.player2,
            .schedule-table td input.player3, .schedule-table td input.player4 { min-width: 50px; max-width: 60px; }
            .schedule-table td input.score { min-width: 50px; max-width: 60px; }
            .schedule-table th, .schedule-table td { padding: 4px 1px; }
            .schedule-table td { border: 0.5px solid var(--border-color); }
            .btn { padding: 8px 12px; font-size: 0.9rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1>2025 래랑가로스</h1>
        <div class="section">
            <h2>경기 일정</h2>
            <div id="schedule-container"></div>
            <button id="save-all" class="btn">모든 데이터 저장</button>
            <button id="update-ranking" class="btn update-btn">순위 업데이트</button>
        </div>
        <div class="section">
            <h2>시즌 순위표</h2>
            <div class="ranking-filter">
                <button class="filter-btn active" data-filter="all">통합 순위</button>
                <button class="filter-btn" data-filter="male">남자 순위</button>
                <button class="filter-btn" data-filter="female">여자 순위</button>
            </div>
            <div class="table-wrapper">
                <table id="ranking-table">
                    <thead><tr><th>순위</th><th>선수</th><th>MMR</th><th>우승</th><th>승</th><th>패</th><th>승률(%)</th><th>평균 게임 득실 항목</th><th>접전률(%)</th><th>압도승률(%)</th><th>압도패률(%)</th><th>최고 파트너</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <button id="toggle-rankings" class="btn toggle-btn">더보기</button>
            <div class="btn-group">
                <a href="dash.html" class="btn" id="dashboard-link">통계 대시보드</a>
                <button id="kakao-share-btn" class="btn">카카오톡 공유</button>
                <button id="download-csv" class="btn">CSV 다운로드</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

<script type="module">
    let gk_isXlsx = false;
    let gk_xlsxFileLookup = {};
    let gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                const workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                const filteredData = jsonData.filter(row => row.some(filledCell));
                let headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                const csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)), { header: 1 });
                console.log(`XLSX 파일 ${filename} 파싱 성공`);
                return csv;
            } catch (e) {
                console.error("XLSX 파싱 오류:", e.name, e.message, e.stack);
                showToast(`XLSX 파싱 실패: ${e.message || '알 수 없는 오류'}`);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, collection, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = { 
        apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", 
        authDomain: "tennis-plan-jibung.firebaseapp.com", 
        projectId: "tennis-plan-jibung", 
        storageBucket: "tennis-plan-jibung.appspot.com", 
        messagingSenderId: "491083537160", 
        appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" 
    };

    let db;
    try {
        db = getFirestore(initializeApp(firebaseConfig));
        console.log("Firebase 초기화 성공!");
    } catch (e) { 
        console.error("Firebase 초기화 실패:", e.name, e.code, e.message, e.stack);
        showToast(`Firebase 초기화 실패: ${e.message || '알 수 없는 오류'}`);
    }

    let currentFilter = 'all';

    function showToast(message) {
        const toast = document.getElementById('toast');
        if (toast) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        } else {
            console.warn("Toast 요소 없음!");
        }
    }

    function createScheduleRounds() {
        const container = document.getElementById('schedule-container');
        if (!container) {
            console.error("schedule-container 요소 없음!");
            showToast("스케줄 컨테이너 오류!");
            return;
        }
        let roundsHtml = '';
        for (let group = 0; group < 6; group++) {
            const startRound = group * 10 + 1;
            const endRound = (group + 1) * 10;
            roundsHtml += `<details class="round-group"><summary>${startRound} ~ ${endRound}회차</summary><div class="round-group-content">`;
            for (let i = startRound; i <= endRound; i++) {
                roundsHtml += `
                <details>
                    <summary>${i}회차</summary>
                    <div class="table-wrapper">
                        <table class="schedule-table" data-round-id="${i}">
                            <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                            <tbody>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                            </tbody>
                        </table>
                    </div>
                </details>`;
            }
            roundsHtml += `</div></details>`;
        }
        container.innerHTML = roundsHtml;
        console.log("회차 일정표 렌der링 완료!");
    }

    function createRankingRows() {
        const rankingBody = document.querySelector('#ranking-table tbody');
        if (!rankingBody) {
            console.error("ranking-table tbody 요소 없음!");
            showToast("순위표 오류!");
            return;
        }
        let rowsHtml = '';
        for (let i = 1; i <= 50; i++) {
            rowsHtml += `
            <tr${i > 20 ? ' class="lower-rank"' : ''}>
                <td class="rank-cell">${i}</td>
                <td><input type="text" placeholder="선수 ${i}" class="ranking-player"></td>
                <td><input type="text" class="mmr readonly" readonly></td>
                <td><span class="championship-star"></span></td>
                <td><input type="text" class="wins readonly" readonly></td>
                <td><input type="text" class="losses readonly" readonly></td>
                <td><input type="text" class="win-rate readonly" readonly></td>
                <td><input type="text" class="avg-game-diff readonly" readonly></td>
                <td><input type="text" class="close-rate readonly" readonly></td>
                <td><input type="text" class="dominant-wins readonly" readonly></td>
                <td><input type="text" class="dominant-losses readonly" readonly></td>
                <td><input type="text" class="best-partner readonly" readonly></td>
            </tr>`;
        }
        rankingBody.innerHTML = rowsHtml;
        console.log("순위표 렌der링 완료!");
    }

    async function saveAllData() {
        if (!db) {
            showToast('DB 연결 실패!');
            return;
        }
        const saveAllBtn = document.getElementById('save-all');
        saveAllBtn.disabled = true;
        try {
            const batch = writeBatch(db);

            const scheduleData = [];
            document.querySelectorAll('.schedule-table').forEach(table => {
                const roundId = table.getAttribute('data-round-id');
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();
                    if (player1 && player2 && player3 && player4) {
                        scheduleData.push({
                            round: parseInt(roundId),
                            players: [player1, player2, player3, player4],
                            score: scoreInput || ''
                        });
                    }
                });
            });
            const scheduleDocRef = doc(db, 'league', 'data', 'schedule', 'v1');
            batch.set(scheduleDocRef, { matches: scheduleData, timestamp: serverTimestamp() }, { merge: true });

            const matchDataList = [];
            document.querySelectorAll('.schedule-table').forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();
                    if (player1 && player2 && player3 && player4 && scoreInput && /^\d+-\d+$/.test(scoreInput)) {
                        const [score1, score2] = scoreInput.split('-').map(Number);
                        const winner = score1 > score2 ? (player1 || player2) : (player3 || player4);
                        const gameDiff = Math.abs(score1 - score2);
                        matchDataList.push({
                            player1: player1 || player2,
                            player2: player3 || player4,
                            winner,
                            gameDiff,
                            timestamp: serverTimestamp()
                        });
                    }
                });
            });
            matchDataList.forEach((match, index) => {
                const matchDocRef = doc(collection(db, 'league/matches/data'), `match_${Date.now()}_${index}`);
                batch.set(matchDocRef, match);
            });

            const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
            const rankingData = Array.from(rankingRows).map(row => {
                const rawName = row.querySelector('.ranking-player').value.trim();
                const name = rawName.replace(/\*/g, '');
                return {
                    name,
                    mmr: row.querySelector('.mmr').value || '0',
                    championships: row.querySelector('.championship-star')?.dataset.count || '0',
                    wins: row.querySelector('.wins').value || '0',
                    losses: row.querySelector('.losses').value || '0',
                    winRate: row.querySelector('.win-rate').value || '0',
                    avgGameDiff: row.querySelector('.avg-game-diff').value || '0.00',
                    closeRate: row.querySelector('.close-rate').value || '0',
                    dominantWins: row.querySelector('.dominant-wins').value || '0',
                    dominantLosses: row.querySelector('.dominant-losses').value || '0',
                    bestPartner: row.querySelector('.best-partner').value || '-',
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: parseFloat(row.querySelector('.mmr').dataset.seasonMMRIncrease) || 0
                };
            }).filter(player => player.name);
            const rankingDocRef = doc(db, 'league', 'data', 'rankings', 'v1');
            batch.set(rankingDocRef, { players: rankingData, timestamp: serverTimestamp() }, { merge: true });

            const rankingHistoryDocRef = doc(db, 'league', 'data', 'rankingHistory', 'v1');
            const rankingHistorySnap = await getDoc(rankingHistoryDocRef);
            const existingHistory = rankingHistorySnap.exists() ? rankingHistorySnap.data().snapshots || [] : [];
            const newSnapshot = {
                snapshotId: existingHistory.length + 1,
                createdAt: new Date().toISOString(),
                rankings: rankingData.map((player, index) => ({
                    name: player.name,
                    rank: index + 1
                }))
            };
            existingHistory.push(newSnapshot);
            batch.set(rankingHistoryDocRef, { snapshots: existingHistory }, { merge: true });

            await batch.commit();
            console.log("통합 데이터 및 랭킹 히스토리 저장 성공!");
            showToast("모든 데이터 저장 완료!");
        } catch (e) {
            console.error("데이터 저장 실패:", e.name, e.code, e.message, e.stack);
            showToast(`데이터 저장 실패: ${e.message || '알 수 없는 오류'}`);
            if (e.code === 'unavailable') {
                console.log("오프라인 모드: 데이터가 로컬 캐시에 큐잉됨.");
                showToast("오프라인 모드: 데이터가 나중에 동기화됩니다!");
            }
        } finally {
            saveAllBtn.disabled = false;
        }
    }

    async function loadData() {
        if (!db) {
            showToast("DB 연결 실패");
            return;
        }
        try {
            const scheduleDoc = await getDoc(doc(db, 'league', 'data', 'schedule', 'v1'));
            if (scheduleDoc.exists()) {
                const scheduleData = scheduleDoc.data().matches || [];
                document.querySelectorAll('.schedule-table').forEach(table => {
                    const roundId = table.getAttribute('data-round-id');
                    const matches = scheduleData.filter(m => m.round == roundId);
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach((row, index) => {
                        const match = matches[index];
                        if (match) {
                            row.querySelector('.player1').value = match.players[0] || '';
                            row.querySelector('.player2').value = match.players[1] || '';
                            row.querySelector('.player3').value = match.players[2] || '';
                            row.querySelector('.player4').value = match.players[3] || '';
                            row.querySelector('.score').value = match.score || '';
                        }
                    });
                });
                console.log("스케줄 데이터 로드 완료!");
            } else {
                console.warn("스케줄 데이터 없음!");
                showToast("스케줄 데이터가 없습니다!");
            }

            const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            if (rankingDoc.exists()) {
                const rankingData = rankingDoc.data().players || [];
                const streaks = {}; // 연승 데이터를 계산하기 위한 객체
                rankingData.forEach(player => {
                    streaks[player.name] = { count: 0, isWin: false };
                    // 연승 계산: wins와 losses를 기반으로 간접 추정 (정확한 연승은 매치 데이터 필요)
                    const totalGames = parseInt(player.wins) + parseInt(player.losses);
                    if (totalGames > 0 && parseInt(player.wins) > 0) {
                        // 단순히 승률 기반으로 연승 추정 (실제 연승은 매치 로그로 개선 가능)
                        const winStreakEstimate = Math.min(parseInt(player.wins), Math.floor(totalGames * (parseInt(player.winRate) / 100)));
                        streaks[player.name].count = winStreakEstimate > 0 ? winStreakEstimate : 0;
                        streaks[player.name].isWin = parseInt(player.wins) > parseInt(player.losses);
                    }
                });

                document.querySelectorAll('#ranking-table tbody tr').forEach((row, index) => {
                    const player = rankingData[index];
                    if (player) {
                        row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                        row.querySelector('.mmr').value = player.mmr || '0';
                        row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                        const champStar = row.querySelector('.championship-star');
                        champStar.dataset.count = player.championships;
                        champStar.textContent = player.championships == 1 ? '⭐' : player.championships > 1 ? `⭐(${player.championships})` : '';
                        row.querySelector('.wins').value = player.wins || '0';
                        row.querySelector('.losses').value = player.losses || '0';
                        row.querySelector('.win-rate').value = player.winRate || '0';
                        row.querySelector('.avg-game-diff').value = player.avgGameDiff || '0.00';
                        row.querySelector('.close-rate').value = player.closeRate || '0';
                        row.querySelector('.dominant-wins').value = player.dominantWins || '0';
                        row.querySelector('.dominant-losses').value = player.dominantLosses || '0';
                        row.querySelector('.best-partner').value = player.bestPartner || '-';
                        // 연승 표시
                        const streak = streaks[player.name] || { count: 0, isWin: false };
                        row.cells[0].innerHTML = `${index + 1}<span class="streak-cell ${streak.count > 0 ? (streak.isWin ? 'streak-win' : 'streak-loss') : 'streak-none'}">${streak.count > 0 ? (streak.isWin ? `W${streak.count}` : `L${streak.count}`) : '–'}</span>`;
                    }
                });
                console.log("랭킹 데이터 로드 완료!");
            } else {
                console.warn("랭킹 데이터 없음!");
                showToast("랭킹 데이터가 없습니다!");
            }
        } catch (e) {
            console.error("로드 실패:", e.name, e.code, e.message, e.stack);
            showToast(`데이터 로드 실패: ${e.message || '알 수 없는 오류'}`);
        }
    }

    async function updateRanking() {
        const updateRankingBtn = document.getElementById('update-ranking');
        updateRankingBtn.disabled = true;

        const BASE_MMR = 1500;
        const BASE_K = 28;
        const BASE_GAMES = 20;
        const MALE_TEAM_WIN_HANDICAP = 0.5;
        const MIXED_TEAM_LOSS_HANDICAP = 0.5;
        const HANDICAP_BASE_POINT = 1500;
        const HANDICAP_ZERO_POINT = 1650;
        const HANDICAP_MAX = 150;

        const players = {};
        const partnerStats = {};
        const streaks = {};

        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const name = rawName.replace(/\*/g, '');
            if (name && !players[name]) {
                players[name] = {
                    name,
                    wins: 0,
                    losses: 0,
                    winRate: 0,
                    gameDiff: 0,
                    avgGameDiff: 0,
                    mmr: BASE_MMR,
                    championships: 0,
                    closeWins: 0,
                    closeSets: 0,
                    closeLosses: 0,
                    dominantWins: 0,
                    dominantLosses: 0,
                    totalSets: 0,
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: 0
                };
                partnerStats[name] = {};
                streaks[name] = { count: 0, isWin: false };
            }
        });

        const scheduleTables = document.querySelectorAll('.schedule-table');
        scheduleTables.forEach((table) => {
            let roundHasMixedMatch = false;
            const roundId = table.getAttribute('data-round-id');
            const rows = table.querySelectorAll('tbody tr');
            let roundWins = {};

            rows.forEach(row => {
                const p1Raw = row.querySelector('.player1').value.trim();
                const p2Raw = row.querySelector('.player2').value.trim();
                const p3Raw = row.querySelector('.player3').value.trim();
                const p4Raw = row.querySelector('.player4').value.trim();
                const score = row.querySelector('.score').value.trim();

                const p1 = p1Raw.replace(/\*/g, '');
                const p2 = p2Raw.replace(/\*/g, '');
                const p3 = p3Raw.replace(/\*/g, '');
                const p4 = p4Raw.replace(/\*/g, '');

                if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;

                [p1, p2, p3, p4].forEach((name, idx) => {
                    if (name && !players[name]) {
                        players[name] = {
                            name,
                            wins: 0,
                            losses: 0,
                            winRate: 0,
                            gameDiff: 0,
                            avgGameDiff: 0,
                            mmr: BASE_MMR,
                            championships: 0,
                            closeWins: 0,
                            closeSets: 0,
                            closeLosses: 0,
                            dominantWins: 0,
                            dominantLosses: 0,
                            totalSets: 0,
                            isFemale: [p1Raw, p2Raw, p3Raw, p4Raw][idx].includes('*'),
                            seasonMMRIncrease: 0
                        };
                        partnerStats[name] = {};
                        streaks[name] = { count: 0, isWin: false };
                    }
                });

                const team1IsMixed = p1Raw.includes('*') || p2Raw.includes('*');
                const team2IsMixed = p3Raw.includes('*') || p4Raw.includes('*');
                const team1IsMale = !team1IsMixed;
                const team2IsMale = !team2IsMixed;

                if (team1IsMixed || team2IsMixed) roundHasMixedMatch = true;

                const getDynamicHandicap = (mmr) => {
                    if (mmr >= HANDICAP_ZERO_POINT) return 0;
                    if (mmr <= HANDICAP_BASE_POINT) return HANDICAP_MAX;
                    const progress = (mmr - HANDICAP_BASE_POINT) / (HANDICAP_ZERO_POINT - HANDICAP_BASE_POINT);
                    return Math.max(0, HANDICAP_MAX * (1 - progress));
                };

                let team1MMR = (players[p1].mmr + players[p2].mmr) / 2;
                let team2MMR = (players[p3].mmr + players[p4].mmr) / 2;
                let effectiveTeam1MMR = team1MMR;
                let effectiveTeam2MMR = team2MMR;

                if (team1IsMixed) {
                    let handicap = 0;
                    if (p1Raw.includes('*')) handicap += getDynamicHandicap(players[p1].mmr);
                    if (p2Raw.includes('*')) handicap += getDynamicHandicap(players[p2].mmr);
                    effectiveTeam1MMR += handicap / (p1Raw.includes('*') && p2Raw.includes('*') ? 2 : 1);
                    effectiveTeam1MMR *= 1.5;
                }
                if (team2IsMixed) {
                    let handicap = 0;
                    if (p3Raw.includes('*')) handicap += getDynamicHandicap(players[p3].mmr);
                    if (p4Raw.includes('*')) handicap += getDynamicHandicap(players[p4].mmr);
                    effectiveTeam2MMR += handicap / (p3Raw.includes('*') && p4Raw.includes('*') ? 2 : 1);
                    effectiveTeam2MMR *= 1.5;
                }

                const expected1 = 1 / (1 + Math.pow(10, (effectiveTeam2MMR - effectiveTeam1MMR) / 400));
                const [score1, score2] = score.split('-').map(Number);
                const actual1 = score1 > score2 ? 1 : 0; // 팀 1 승패
                const actual2 = score1 < score2 ? 1 : 0; // 팀 2 승패
                const gameDiff = Math.abs(score1 - score2);
                const scoreWeight = 0.8 + (gameDiff / 6) * 0.7;

                const updatePlayerMMR = (player, opponentTeamMMR, isWinner) => {
                    const totalGames = player.wins + player.losses;
                    let K = BASE_K / (1 + Math.log10(totalGames / BASE_GAMES + 1)) * (1 + Math.min(1, totalGames / 20)); // 총 경기 수 보너스 적용
                    if (player.mmr > 1800) {
                        K *= Math.max(0.3, 1 - (player.mmr - 1800) / 1000);
                    }
                    const expectedWinRate = 1 / (1 + Math.pow(10, (opponentTeamMMR - player.mmr) / 400));
                    let mmrChange = K * ((isWinner ? 1 : 0) - expectedWinRate);
                    let opponentWeight = Math.min(1, opponentTeamMMR / player.mmr);
                    if (player.mmr > 1800) {
                        opponentWeight *= Math.max(0.5, 1 - (player.mmr - 1800) / 2000);
                    }
                    mmrChange *= opponentWeight * scoreWeight;
                    return mmrChange;
                };

                let mmrChange1 = updatePlayerMMR(players[p1], team2MMR, actual1);
                let mmrChange2 = updatePlayerMMR(players[p2], team2MMR, actual1);
                let mmrChange3 = updatePlayerMMR(players[p3], team1MMR, actual2);
                let mmrChange4 = updatePlayerMMR(players[p4], team1MMR, actual2);

                if (team1IsMale && team2IsMixed && actual1 === 1) {
                    mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                } else if (team2IsMale && team1IsMixed && actual2 === 1) {
                    mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                }

                if (team1IsMixed && actual1 === 0) {
                    mmrChange1 *= MIXED_TEAM_LOSS_HANDICAP;
                    mmrChange2 *= MIXED_TEAM_LOSS_HANDICAP;
                } else if (team2IsMixed && actual2 === 0) {
                    mmrChange3 *= MIXED_TEAM_LOSS_HANDICAP;
                    mmrChange4 *= MIXED_TEAM_LOSS_HANDICAP;
                }

                const isClose = score1 - score2 === 1 || score2 - score1 === 1 || score1 - score2 === 2 || score2 - score1 === 2;

                const updatePlayer = (name, isWinner, gameDiff, mmrChangeVal, isCloseGame, isDominantWin, isDominantLoss) => {
                    if (!players[name]) return;
                    players[name].totalSets++;
                    players[name].gameDiff += gameDiff;
                    players[name].mmr += mmrChangeVal;
                    players[name].seasonMMRIncrease += mmrChangeVal;
                    if (isWinner) {
                        players[name].wins++;
                        if (!roundWins[name]) roundWins[name] = 0;
                        roundWins[name]++;
                        if (isCloseGame) players[name].closeWins++;
                        if (streaks[name].isWin) {
                            streaks[name].count++;
                        } else {
                            streaks[name].count = 1;
                            streaks[name].isWin = true;
                        }
                    } else {
                        players[name].losses++;
                        if (isCloseGame) players[name].closeLosses++;
                        if (!streaks[name].isWin && streaks[name].count > 0) {
                            streaks[name].count++;
                        } else {
                            streaks[name].count = 1;
                            streaks[name].isWin = false;
                        }
                    }
                    if (isCloseGame) players[name].closeSets++;
                    if (isDominantWin) players[name].dominantWins++;
                    if (isDominantLoss) players[name].dominantLosses++;
                };

                // 팀 1 플레이어
                updatePlayer(p1, actual1, score1 - score2, mmrChange1, isClose, actual1 === 1 && gameDiff >= 5, actual1 === 0 && gameDiff >= 5);
                updatePlayer(p2, actual1, score1 - score2, mmrChange2, isClose, actual1 === 1 && gameDiff >= 5, actual1 === 0 && gameDiff >= 5);
                // 팀 2 플레이어
                updatePlayer(p3, actual2, score2 - score1, mmrChange3, isClose, actual2 === 1 && gameDiff >= 5, actual2 === 0 && gameDiff >= 5);
                updatePlayer(p4, actual2, score2 - score1, mmrChange4, isClose, actual2 === 1 && gameDiff >= 5, actual2 === 0 && gameDiff >= 5);

                const updatePartnerStats = (player, partner, isWin, gameDiff) => {
                    if (!players[player] || !players[partner]) return;
                    if (!partnerStats[player]) partnerStats[player] = {};
                    if (!partnerStats[player][partner]) {
                        partnerStats[player][partner] = { wins: 0, losses: 0, gameDiffSum: 0, matches: 0 };
                    }
                    const stats = partnerStats[player][partner];
                    stats.matches++;
                    stats.gameDiffSum += gameDiff;
                    if (isWin) stats.wins++; else stats.losses++;
                };

                if (actual1 > 0) {
                    updatePartnerStats(p1, p2, true, score1 - score2);
                    updatePartnerStats(p2, p1, true, score1 - score2);
                    updatePartnerStats(p3, p4, false, score2 - score1);
                    updatePartnerStats(p4, p3, false, score2 - score1);
                } else {
                    updatePartnerStats(p1, p2, false, score1 - score2);
                    updatePartnerStats(p2, p1, false, score1 - score2);
                    updatePartnerStats(p3, p4, true, score2 - score1);
                    updatePartnerStats(p4, p3, true, score2 - score1);
                }
            });

            Object.keys(roundWins).forEach(pName => {
                if (roundWins[pName] === 3 && players[pName]) {
                    const isMalePlayer = !players[pName].isFemale;
                    if (isMalePlayer && roundHasMixedMatch) {
                    } else {
                        players[pName].championships++;
                    }
                }
            });
        });

        let sortedPlayers = Object.values(players).sort((a, b) => b.mmr - a.mmr);
        if (currentFilter === 'male') sortedPlayers = sortedPlayers.filter(p => !p.isFemale);
        else if (currentFilter === 'female') sortedPlayers = sortedPlayers.filter(p => p.isFemale);

        try {
            const historyDocRef = doc(db, 'league', 'data', 'mmrHistory', 'v1');
            const historyDocSnap = await getDoc(historyDocRef);
            const existingHistory = historyDocSnap.exists() ? historyDocSnap.data().snapshots || [] : [];
            const newSnapshot = { 
                game: existingHistory.length + 1,
                createdAt: new Date().toISOString()
            };
            sortedPlayers.forEach(p => {
                if (p.wins > 0 || p.losses > 0) {
                    const cleanName = p.name.replace(/[@.*]+/g, '_').replace(/_+/g, '_').trim();
                    newSnapshot[cleanName] = Math.round(p.mmr);
                }
            });
            if (Object.keys(newSnapshot).length > 1) {
                existingHistory.push(newSnapshot);
                await setDoc(historyDocRef, { snapshots: existingHistory });
                console.log("MMR 히스토리 저장 완료!");
            } else {
                console.warn("MMR 히스토리 데이터 부족!");
                showToast("MMR 히스토리 데이터 부족!");
            }
        } catch (e) {
            console.error("MMR 히스토리 저장 실패:", e.name, e.code, e.message, e.stack);
            showToast(`MMR 히스토리 저장 실패: ${e.message || '알 수 없는 오류'}`);
        }

        const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
        rankingRows.forEach((row, index) => {
            const player = sortedPlayers[index];
            if (player) {
                const totalGames = player.wins + player.losses;
                player.avgGameDiff = player.totalSets > 0 ? (player.gameDiff / player.totalSets).toFixed(2) : '0.00';
                player.winRate = totalGames > 0 ? Math.round((player.wins / totalGames) * 100) : 0;

                row.cells[0].innerHTML = `${index + 1}<span class="streak-cell ${streaks[player.name]?.count > 0 ? (streaks[player.name].isWin ? 'streak-win' : 'streak-loss') : 'streak-none'}">${streaks[player.name]?.count > 0 ? (streaks[player.name].isWin ? `W${streaks[player.name].count}` : `L${streaks[player.name].count}`) : '–'}</span>`;
                row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                row.querySelector('.mmr').value = Math.round(player.mmr);
                row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                const champStar = row.querySelector('.championship-star');
                champStar.dataset.count = player.championships;
                champStar.textContent = player.championships == 1 ? '⭐' : player.championships > 1 ? `⭐(${player.championships})` : '';
                row.querySelector('.wins').value = player.wins;
                row.querySelector('.losses').value = player.losses;
                row.querySelector('.win-rate').value = player.winRate;
                row.querySelector('.avg-game-diff').value = player.avgGameDiff;
                row.querySelector('.close-rate').value = player.totalSets >= 2 ? (player.closeSets === 0 ? '0' : Math.round(player.closeSets / player.totalSets * 100)) : '0';
                row.querySelector('.dominant-wins').value = player.totalSets > 0 ? `${Math.round((player.dominantWins / player.totalSets) * 100)}%(${player.dominantWins}승)` : '0%';
                row.querySelector('.dominant-losses').value = player.totalSets > 0 ? `${Math.round((player.dominantLosses / player.totalSets) * 100)}%(${player.dominantLosses}패)` : '0%';

                let bestPartner = { name: '-', wins: 0, losses: 0, score: -Infinity };
                if (partnerStats[player.name]) {
                    for (const partnerName in partnerStats[player.name]) {
                        const stats = partnerStats[player.name][partnerName];
                        if (stats.matches > 0) {
                            const winPriority = stats.wins;
                            const diffPriority = stats.matches > 0 ? stats.gameDiffSum / stats.matches : 0;
                            const partnerScore = (winPriority * 100) + (diffPriority * 10);
                            if (partnerScore > bestPartner.score) {
                                bestPartner = { name: partnerName, wins: stats.wins, losses: stats.losses, score: partnerScore };
                            }
                        }
                    }
                }
                row.querySelector('.best-partner').value = bestPartner.name === '-' ? '데이터 부족' : `${bestPartner.name.replace(/\*/g, '')} (${bestPartner.wins}승${bestPartner.losses}패)`;
            } else {
                row.cells[0].innerHTML = `${index + 1}<span class="streak-cell streak-none">–</span>`;
                row.querySelectorAll('input:not([type=button])').forEach(input => input.value = '');
                row.querySelector('.championship-star').textContent = '';
            }
        });

        await saveAllData();
        showToast('순위 업데이트 완료!');
        updateRankingBtn.disabled = false;
    }

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
            localStorage.setItem('theme', theme);
        } else {
            console.warn("theme-toggle 요소 없음!");
        }
    }

    function shareOnKakao() {
        console.log("카카오톡 공유 기능 호출");
        // 형의 원본 카카오 공유 로직 삽입 필요
    }

    function downloadCSV() {
        let rankingCSV = '\uFEFF순위,선수,MMR,우승,승,패,승률(%),평균 게임 득실 항목,접전률(%),압도승률(%),압도패률(%),최고 파트너\n';
        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const player = rawName.replace(/\*/g, '');
            if (player) {
                const rank = row.cells[0].textContent.split(' ')[0];
                const mmr = row.querySelector('.mmr').value;
                const championships = row.querySelector('.championship-star')?.dataset.count || '0';
                const wins = row.querySelector('.wins').value;
                const losses = row.querySelector('.losses').value;
                const winRate = row.querySelector('.win-rate').value;
                const avgGameDiff = row.querySelector('.avg-game-diff').value;
                const closeRate = row.querySelector('.close-rate').value;
                const dominantWins = row.querySelector('.dominant-wins').value.replace('%', '').replace('승', '');
                const dominantLosses = row.querySelector('.dominant-losses').value.replace('%', '').replace('패', '');
                const bestPartner = row.querySelector('.best-partner').value;
                rankingCSV += `${rank},"${player}",${mmr},${championships},${wins},${losses},${winRate},${avgGameDiff},${closeRate},${dominantWins},${dominantLosses},"${bestPartner}"\n`;
            }
        });

        const blob = new Blob([rankingCSV], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'raelangaros_rankings.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function waitForElements(selector, callback, retries = 10, delay = 100) {
        let attempts = 0;
        function check() {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0 && document.getElementById('schedule-container') && document.querySelector('#ranking-table tbody')) {
                console.log("DOM 요소 준비 완료:", selector);
                callback();
            } else if (attempts < retries) {
                attempts++;
                console.log(`DOM 요소 대기 중 (${attempts}/${retries})...`);
                setTimeout(check, delay);
            } else {
                console.error("DOM 요소 로드 실패:", selector);
                showToast("페이지 로드 오류!");
            }
        }
        check();
    }

    function setupInputListeners() {
        const saveAllBtn = document.getElementById('save-all');
        const updateRankingBtn = document.getElementById('update-ranking');
        const toggleRankingsBtn = document.getElementById('toggle-rankings');
        if (!saveAllBtn || !updateRankingBtn || !toggleRankingsBtn) {
            console.warn("버튼 요소 없음!");
            showToast("버튼 로드 실패!");
            return;
        }
        saveAllBtn.addEventListener('click', saveAllData);
        updateRankingBtn.addEventListener('click', updateRanking);
        toggleRankingsBtn.addEventListener('click', () => {
            const lowerRanks = document.querySelectorAll('.lower-rank');
            const isVisible = lowerRanks[0]?.classList.contains('show');
            lowerRanks.forEach(row => row.classList.toggle('show'));
            toggleRankingsBtn.textContent = isVisible ? '더보기' : '접기';
        });

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                loadData();
            });
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded 이벤트 실행");
        waitForElements('#schedule-container, #ranking-table tbody', () => {
            applyTheme(localStorage.getItem('theme') || 'dark');
            createScheduleRounds();
            createRankingRows();
            if (db) {
                loadData();
            } else {
                console.warn("DB 연결 없음!");
                showToast("DB 연결 실패!");
            }
            setupInputListeners();
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
            }
            const kakaoShareBtn = document.getElementById('kakao-share-btn');
            if (kakaoShareBtn) {
                kakaoShareBtn.addEventListener('click', shareOnKakao);
            }
            const downloadCsvBtn = document.getElementById('download-csv');
            if (downloadCsvBtn) {
                downloadCsvBtn.addEventListener('click', downloadCSV);
            }
            console.log("이벤트 리스너 설정 완료!");
        });
    });
</script>
</body>
</html>