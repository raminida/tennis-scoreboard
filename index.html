<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 래랑가로스</title>
    <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js" integrity="sha384-y3tIif2B4242xI/mS8d43/p/a1uBoL3w7sL2rS4z0nBjwA/2/g8L/DTrb1JScC4k" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
            --spacing-sm: 8px; --spacing-md: 12px; --spacing-lg: 20px; --radius: 8px;
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: var(--spacing-md); transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1100px; margin: 0 auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; font-weight: 900; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding-top: var(--spacing-lg); margin-bottom: 2rem; letter-spacing: -2px; text-shadow: 2px 2px 10px var(--shadow-color); }
        .section { background: var(--surface-color); padding: var(--spacing-lg); border-radius: var(--radius); box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 2.5rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 1.8rem; font-weight: 700; color: var(--primary-color); margin-bottom: var(--spacing-sm); padding-bottom: var(--spacing-sm); border-bottom: 2px solid var(--border-color); }
        details { margin-bottom: 1rem; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border-color); }
        details summary { padding: var(--spacing-md) 15px; cursor: pointer; font-size: 1.1rem; font-weight: 700; outline: none; transition: background 0.3s ease, color 0.3s ease; background: linear-gradient(135deg, #2a2a2a, #222222); color: var(--secondary-color); }
        html[data-theme="light"] details summary { background: linear-gradient(135deg, #f9f9f9, #f1f1f1); color: var(--text-color); }
        details[open] > summary { background: var(--primary-color); color: var(--bg-color); }
        html[data-theme="light"] details[open] > summary { color: var(--secondary-color); }
        .round-group-content { padding: 15px 10px 5px 10px; background: rgba(0,0,0,0.1); border-top: 1px solid var(--border-color); }
        html[data-theme="light"] .round-group-content { background: rgba(0,0,0,0.02); }
        .table-wrapper { overflow-x: auto; overflow-y: auto; max-height: 70vh; -webkit-overflow-scrolling: touch; } /* 상하 스크롤 지원 */
        table { width: 100%; min-width: 600px; border-collapse: collapse; }
        th, td { padding: var(--spacing-md) 10px; text-align: center; border-bottom: 1px solid var(--border-color); font-size: 0.9rem; white-space: nowrap; }
        #ranking-table thead th { position: sticky; top: 0; background: var(--surface-color); z-index: 10; } /* 상단 고정, z-index 증가 */
        th { font-family: 'Poppins', sans-serif; background-color: rgba(0, 0, 0, 0.2); color: var(--primary-variant-color); font-weight: 700; }
        html[data-theme="light"] th { background-color: #F9FAFB; }
        .rank-cell { font-weight: 900; color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5); position: relative; padding-right: 40px; line-height: 1.2; } /* 순위 숫자 여백 */
        .rank-change { font-size: 0.7rem; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); white-space: nowrap; } /* 변동 옆 배치, 겹침 방지 */
        .rank-up { color: #4CAF50; }
        .rank-down { color: #F44336; }
        .rank-nochange { color: var(--text-secondary-color); }
        #ranking-table th:nth-child(2), #ranking-table td:nth-child(2) { position: sticky; left: 0; background: var(--surface-color); z-index: 1; } /* 선수 이름 고정 */
        input[type="text"] { width: 100%; min-width: 80px; padding: var(--spacing-sm); background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; color: var(--text-color); font-family: 'Noto Sans KR', sans-serif; text-align: center; }
        input.readonly { background-color: #252525; color: var(--text-secondary-color); font-weight: bold; }
        html[data-theme="light"] input.readonly { background-color: #f0f0f0; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: var(--spacing-lg); }
        .btn { display: inline-block; padding: var(--spacing-md) var(--spacing-lg); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: var(--radius); cursor: pointer; font-weight: 700; font-size: 1rem; border: none; text-align: center; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .update-btn { width: 100%; margin-top: var(--spacing-lg); padding: 15px; background: linear-gradient(135deg, var(--accent-gold), #F5B02E); color: var(--bg-color); border: none; border-radius: var(--radius); font-size: 1.2rem; font-weight: 900; cursor: pointer; }
        .toast { position: fixed; bottom: var(--spacing-lg); left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #333, #111); color: #fff; padding: var(--spacing-md) 25px; border-radius: 50px; box-shadow: 0 5px 15px var(--shadow-color); opacity: 0; transition: opacity 0.4s, transform 0.4s; font-weight: 700; z-index: 1000; }
        .toast.show { opacity: 1; }
        .championship-star { color: var(--accent-gold); text-shadow: 0 0 5px var(--accent-gold); font-size: 1.1rem; font-weight: 900; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .ranking-player[value$="*"] { color: var(--primary-variant-color); }
        .ranking-filter { display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md); }
        .filter-btn { padding: var(--spacing-sm) var(--spacing-md); background: var(--surface-color); border: 1px solid var(--border-color); border-radius: var(--radius); cursor: pointer; color: var(--text-color); font-weight: 700; }
        .filter-btn.active { background: var(--primary-color); color: var(--bg-color); }
        .toggle-btn { padding: var(--spacing-sm) var(--spacing-md); margin: var(--spacing-sm) auto; display: block; }
        tr.lower-rank { display: none; }
        tr.lower-rank.show { display: table-row; }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1>2025 래랑가로스</h1>
        <div class="section">
            <h2>경기 일정</h2>
            <div id="schedule-container"></div>
            <button id="save-schedule" class="btn">일정 저장</button>
            <button id="save-matches" class="btn">매치 데이터 저장</button>
            <button id="save-rankings" class="btn">랭킹 저장</button>
            <button id="update-ranking" class="btn update-btn">순위 업데이트</button>
        </div>
        <div class="section">
            <h2>시즌 순위표</h2>
            <div class="ranking-filter">
                <button class="filter-btn active" data-filter="all">통합 순위</button>
                <button class="filter-btn" data-filter="male">남자 순위</button>
                <button class="filter-btn" data-filter="female">여자 순위</button>
            </div>
            <div class="table-wrapper">
                <table id="ranking-table">
                    <thead><tr><th>순위</th><th>선수</th><th>MMR</th><th>우승</th><th>승</th><th>패</th><th>경기당 평균 게임 득실</th><th>접전률(%)</th><th>압도승률(%)</th><th>최고 파트너</th><th>최하 파트너</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <button id="toggle-rankings" class="btn toggle-btn">더보기</button>
            <div class="btn-group">
                <a href="dash.html" class="btn" id="dashboard-link">통계 대시보드</a>
                <button id="kakao-share-btn" class="btn">카카오톡 공유</button>
                <button id="download-csv" class="btn">CSV 다운로드</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

<script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error("XLSX 파싱 오류:", e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, collection, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = { 
        apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", 
        authDomain: "tennis-plan-jibung.firebaseapp.com", 
        projectId: "tennis-plan-jibung", 
        storageBucket: "tennis-plan-jibung.appspot.com", 
        messagingSenderId: "491083537160", 
        appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" 
    };

    let db;
    try {
        db = getFirestore(initializeApp(firebaseConfig));
    } catch (e) { 
        console.error("Firebase 초기화 실패:", e); 
        showToast("Firebase 초기화 실패!");
    }

    let currentFilter = 'all';

    function showToast(message) {
        const toast = document.getElementById('toast');
        if (toast) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        } else {
            console.warn("Toast 요소 없음!");
        }
    }

    function createScheduleRounds() {
        const container = document.getElementById('schedule-container');
        if (!container) {
            console.error("schedule-container 요소 없음!");
            showToast("스케줄 컨테이너 오류!");
            return;
        }
        let roundsHtml = '';
        for (let group = 0; group < 6; group++) {
            const startRound = group * 10 + 1;
            const endRound = (group + 1) * 10;
            roundsHtml += `<details class="round-group"><summary>${startRound} ~ ${endRound}회차</summary><div class="round-group-content">`;
            for (let i = startRound; i <= endRound; i++) {
                roundsHtml += `
                <details>
                    <summary>${i}회차</summary>
                    <div class="table-wrapper">
                        <table class="schedule-table" data-round-id="${i}">
                            <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                            <tbody>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                                <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                            </tbody>
                        </table>
                    </div>
                </details>`;
            }
            roundsHtml += `</div></details>`;
        }
        container.innerHTML = roundsHtml;
        console.log("회차 일정표 렌더링 완료!");
    }

    function createRankingRows() {
        const rankingBody = document.querySelector('#ranking-table tbody');
        if (!rankingBody) {
            console.error("ranking-table tbody 요소 없음!");
            showToast("순위표 오류!");
            return;
        }
        let rowsHtml = '';
        for (let i = 1; i <= 50; i++) {
            rowsHtml += `
            <tr${i > 20 ? ' class="lower-rank"' : ''}>
                <td class="rank-cell">${i}<span class="rank-change"></span></td><td><input type="text" placeholder="선수 ${i}" class="ranking-player"></td><td><input type="text" class="mmr readonly" readonly></td><td><span class="championship-star"></span></td><td><input type="text" class="wins readonly" readonly></td><td><input type="text" class="losses readonly" readonly></td><td><input type="text" class="avg-game-diff readonly" readonly></td><td><input type="text" class="close-rate readonly" readonly></td><td><input type="text" class="dominant-wins readonly" readonly></td><td><input type="text" class="best-partner readonly" readonly></td><td><input type="text" class="worst-partner readonly" readonly></td>
            </tr>`;
        }
        rankingBody.innerHTML = rowsHtml;
        console.log("순위표 렌더링 완료!");
    }

    async function saveSchedule() {
        if (!db) {
            showToast('DB 연결 실패');
            return;
        }
        try {
            const scheduleTables = document.querySelectorAll('.schedule-table');
            const scheduleData = [];

            scheduleTables.forEach(table => {
                const roundId = table.getAttribute('data-round-id');
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();

                    if (player1 && player2 && player3 && player4) {
                        scheduleData.push({
                            round: parseInt(roundId),
                            players: [player1, player2, player3, player4],
                            score: scoreInput || ''
                        });
                    }
                });
            });

            await setDoc(doc(db, 'league', 'data', 'schedule', 'v1'), { matches: scheduleData, timestamp: serverTimestamp() }, { merge: true });
            console.log("일정 데이터 저장 성공:", scheduleData);
            showToast("일정 저장 완료!");
        } catch (e) {
            console.error("일정 저장 실패:", e.message);
            showToast(`일정 저장 실패: ${e.message}`);
        }
    }

    async function saveMatches() {
        if (!db) {
            console.error("DB 객체 없음!");
            showToast('DB 연결 실패');
            return;
        }
        console.log("DB 객체:", db);
        try {
            const matchDataList = [];
            const scheduleTables = document.querySelectorAll('.schedule-table');
            scheduleTables.forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();

                    if (player1 && player2 && player3 && player4 && scoreInput && /^\d+-\d+$/.test(scoreInput)) {
                        const [score1, score2] = scoreInput.split('-').map(Number);
                        const winner = score1 > score2 ? (player1 || player2) : (player3 || player4);
                        const gameDiff = Math.abs(score1 - score2);

                        const matchEntry = {
                            player1: player1 || player2,
                            player2: player3 || player4,
                            winner: winner,
                            gameDiff: gameDiff,
                            timestamp: serverTimestamp()
                        };
                        matchDataList.push(matchEntry);
                    }
                });
            });

            console.log("저장할 매치 데이터:", matchDataList);
            if (matchDataList.length === 0) {
                showToast("저장할 매치 데이터 없음!");
                return;
            }

            const batch = writeBatch(db);
            matchDataList.forEach((match, index) => {
                const docRef = doc(collection(db, 'league/matches/data'), `match_${Date.now()}_${index}`);
                batch.set(docRef, match);
            });
            await batch.commit();
            console.log("매치 데이터 저장 성공:", matchDataList);
            showToast("매치 데이터 저장 완료!");
        } catch (e) {
            console.error("매치 데이터 저장 실패:", e);
            showToast(`매치 데이터 저장 실패: ${e.message}`);
        }
    }

    async function saveRankings() {
        if (!db) {
            showToast('DB 연결 실패');
            return;
        }
        try {
            const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
            const rankingData = Array.from(rankingRows).map(row => {
                const rawName = row.querySelector('.ranking-player').value.trim();
                const name = rawName.replace(/\*/g, '');
                return {
                    name,
                    mmr: row.querySelector('.mmr').value || '0',
                    championships: row.querySelector('.championship-star')?.dataset.count || '0',
                    wins: row.querySelector('.wins').value || '0',
                    losses: row.querySelector('.losses').value || '0',
                    avgGameDiff: row.querySelector('.avg-game-diff').value || '0',
                    closeRate: row.querySelector('.close-rate').value || '0',
                    dominantWins: row.querySelector('.dominant-wins').value || '0',
                    bestPartner: row.querySelector('.best-partner').value || '-',
                    worstPartner: row.querySelector('.worst-partner').value || '-',
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: parseFloat(row.querySelector('.mmr').dataset.seasonMMRIncrease) || 0
                };
            }).filter(player => player.name);

            await setDoc(doc(db, 'league', 'data', 'rankings', 'v1'), { players: rankingData, timestamp: serverTimestamp() }, { merge: true });
            console.log("랭킹 데이터 저장 성공:", rankingData);
            showToast("랭킹 저장 완료!");
        } catch (e) {
            console.error("랭킹 저장 실패:", e.message);
            showToast(`랭킹 저장 실패: ${e.message}`);
        }
    }

    async function loadData() {
        if (!db) {
            showToast("DB 연결 실패");
            return;
        }
        try {
            const scheduleDoc = await getDoc(doc(db, 'league', 'data', 'schedule', 'v1'));
            if (scheduleDoc.exists()) {
                const scheduleData = scheduleDoc.data().matches || [];
                document.querySelectorAll('.schedule-table tbody tr').forEach((row, index) => {
                    const match = scheduleData[index];
                    if (match) {
                        row.querySelector('.player1').value = match.players[0] || '';
                        row.querySelector('.player2').value = match.players[1] || '';
                        row.querySelector('.player3').value = match.players[2] || '';
                        row.querySelector('.player4').value = match.players[3] || '';
                        row.querySelector('.score').value = match.score || '';
                    }
                });
                console.log("스케줄 데이터 로드 완료:", scheduleData);
            }
            const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            if (rankingDoc.exists()) {
                const rankingData = rankingDoc.data().players || [];
                document.querySelectorAll('#ranking-table tbody tr').forEach((row, index) => {
                    const player = rankingData[index];
                    if (player) {
                        row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                        row.querySelector('.mmr').value = player.mmr || '0';
                        row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                        const champStar = row.querySelector('.championship-star');
                        champStar.dataset.count = player.championships;
                        champStar.textContent = '⭐'.repeat(player.championships);
                        row.querySelector('.wins').value = player.wins || '0';
                        row.querySelector('.losses').value = player.losses || '0';
                        row.querySelector('.avg-game-diff').value = player.avgGameDiff || '0';
                        row.querySelector('.close-rate').value = player.closeRate || '0';
                        row.querySelector('.dominant-wins').value = player.dominantWins || '0';
                        row.querySelector('.best-partner').value = player.bestPartner || '-';
                        row.querySelector('.worst-partner').value = player.worstPartner || '-';
                    }
                });
                console.log("랭킹 데이터 로드 완료:", rankingData);
            }
            await updateRanking();
        } catch (e) {
            console.error("로드 실패:", e.message);
            showToast(`데이터 로드 실패: ${e.message}`);
        }
    }

    async function updateRanking() {
        const BASE_MMR = 1500;
        const BASE_K = 28;
        const BASE_GAMES = 30;
        const MALE_TEAM_WIN_HANDICAP = 0.5;
        const MIXED_TEAM_LOSS_HANDICAP = 0.5;
        const HANDICAP_BASE_POINT = 1500;
        const HANDICAP_ZERO_POINT = 1650;
        const HANDICAP_MAX = 150;
        const MANDATORY_PLAYER = "정래민";
        const MANDATORY_PLAYER_MMR_WEIGHT = 0.7;

        const players = {};
        const partnerStats = {};

        // 이전 순위 저장을 위한 변수
        let previousRankings = {};
        try {
            const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            if (rankingDoc.exists()) {
                const rankingData = rankingDoc.data().players || [];
                rankingData.forEach((player, index) => {
                    const name = player.name;
                    previousRankings[name] = index + 1;
                });
            }
        } catch (e) {
            console.error("이전 랭킹 로드 실패:", e.message);
        }

        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const name = rawName.replace(/\*/g, '');
            if (name && !players[name]) {
                players[name] = {
                    name,
                    wins: 0,
                    losses: 0,
                    gameDiff: 0,
                    avgGameDiff: 0,
                    mmr: BASE_MMR,
                    championships: 0,
                    closeWins: 0,
                    closeSets: 0,
                    closeLosses: 0,
                    dominantWins: 0,
                    totalSets: 0,
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: 0
                };
                partnerStats[name] = {};
            }
        });

        const scheduleTables = document.querySelectorAll('.schedule-table');
        scheduleTables.forEach((table) => {
            let roundHasMixedMatch = false;
            const rows = table.querySelectorAll('tbody tr');
            let roundWins = {};

            rows.forEach(row => {
                const p1Raw = row.querySelector('.player1').value.trim();
                const p2Raw = row.querySelector('.player2').value.trim();
                const p3Raw = row.querySelector('.player3').value.trim();
                const p4Raw = row.querySelector('.player4').value.trim();
                const score = row.querySelector('.score').value.trim();

                const p1 = p1Raw.replace(/\*/g, '');
                const p2 = p2Raw.replace(/\*/g, '');
                const p3 = p3Raw.replace(/\*/g, '');
                const p4 = p4Raw.replace(/\*/g, '');

                if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;

                [p1, p2, p3, p4].forEach((name, idx) => {
                    if (name && !players[name]) {
                        players[name] = {
                            name,
                            wins: 0,
                            losses: 0,
                            gameDiff: 0,
                            avgGameDiff: 0,
                            mmr: BASE_MMR,
                            championships: 0,
                            closeWins: 0,
                            closeSets: 0,
                            closeLosses: 0,
                            dominantWins: 0,
                            totalSets: 0,
                            isFemale: [p1Raw, p2Raw, p3Raw, p4Raw][idx].includes('*'),
                            seasonMMRIncrease: 0
                        };
                        partnerStats[name] = {};
                    }
                });

                const team1IsMixed = p1Raw.includes('*') || p2Raw.includes('*');
                const team2IsMixed = p3Raw.includes('*') || p4Raw.includes('*');
                const team1IsMale = !team1IsMixed;
                const team2IsMale = !team2IsMixed;

                if (team1IsMixed || team2IsMixed) {
                    roundHasMixedMatch = true;
                }

                const getDynamicHandicap = (mmr) => {
                    if (mmr >= HANDICAP_ZERO_POINT) return 0;
                    if (mmr <= HANDICAP_BASE_POINT) return HANDICAP_MAX;
                    const progress = (mmr - HANDICAP_BASE_POINT) / (HANDICAP_ZERO_POINT - HANDICAP_BASE_POINT);
                    return Math.max(0, HANDICAP_MAX * (1 - progress));
                };

                let team1MMR = (players[p1].mmr + players[p2].mmr) / 2;
                let team2MMR = (players[p3].mmr + players[p4].mmr) / 2;
                let effectiveTeam1MMR = team1MMR;
                let effectiveTeam2MMR = team2MMR;

                if (team1IsMixed) {
                    let handicap = 0;
                    if (p1Raw.includes('*')) handicap += getDynamicHandicap(players[p1].mmr);
                    if (p2Raw.includes('*')) handicap += getDynamicHandicap(players[p2].mmr);
                    effectiveTeam1MMR += handicap / (p1Raw.includes('*') && p2Raw.includes('*') ? 2 : 1);
                    effectiveTeam1MMR *= 1.5;
                }
                if (team2IsMixed) {
                    let handicap = 0;
                    if (p3Raw.includes('*')) handicap += getDynamicHandicap(players[p3].mmr);
                    if (p4Raw.includes('*')) handicap += getDynamicHandicap(players[p4].mmr);
                    effectiveTeam2MMR += handicap / (p3Raw.includes('*') && p4Raw.includes('*') ? 2 : 1);
                    effectiveTeam2MMR *= 1.5;
                }

                const expected1 = 1 / (1 + Math.pow(10, (effectiveTeam2MMR - effectiveTeam1MMR) / 400));
                const [score1, score2] = score.split('-').map(Number);
                const actual1 = score1 > score2 ? 1 : 0;
                const gameDiff = Math.abs(score1 - score2);
                const scoreWeight = 0.8 + (gameDiff / 6) * 0.7;

                const updatePlayerMMR = (player, opponentTeamMMR, isWinner) => {
                    const totalGames = player.wins + player.losses;
                    let K = BASE_K / (1 + Math.log10(totalGames / BASE_GAMES + 1));
                    
                    if (player.mmr > 1800) {
                        K *= Math.max(0.3, 1 - (player.mmr - 1800) / 1000);
                    }
                    
                    const expectedWinRate = 1 / (1 + Math.pow(10, (opponentTeamMMR - player.mmr) / 400));
                    let mmrChange = K * ((isWinner ? 1 : 0) - expectedWinRate);
                    
                    let opponentWeight = Math.min(1, opponentTeamMMR / player.mmr);
                    if (player.mmr > 1800) {
                        opponentWeight *= Math.max(0.5, 1 - (player.mmr - 1800) / 2000);
                    }
                    mmrChange *= opponentWeight * scoreWeight;
                    
                    if (player.name === MANDATORY_PLAYER) {
                        mmrChange *= MANDATORY_PLAYER_MMR_WEIGHT;
                    }
                    
                    return mmrChange;
                };

                let mmrChange1 = updatePlayerMMR(players[p1], team2MMR, actual1);
                let mmrChange2 = updatePlayerMMR(players[p2], team2MMR, actual1);
                let mmrChange3 = updatePlayerMMR(players[p3], team1MMR, 1 - actual1);
                let mmrChange4 = updatePlayerMMR(players[p4], team1MMR, 1 - actual1);

                if (team1IsMale && team2IsMixed && actual1 === 1) {
                    mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                } else if (team2IsMale && team1IsMixed && actual1 === 0) {
                    mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                    mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                }

                if (team1IsMixed && actual1 === 0) {
                    mmrChange1 *= MIXED_TEAM_LOSS_HANDICAP;
                    mmrChange2 *= MIXED_TEAM_LOSS_HANDICAP;
                } else if (team2IsMixed && actual1 === 1) {
                    mmrChange3 *= MIXED_TEAM_LOSS_HANDICAP;
                    mmrChange4 *= MIXED_TEAM_LOSS_HANDICAP;
                }

                const isClose = score1 - score2 === 1 || score2 - score1 === 1 || score1 - score2 === 2 || score2 - score1 === 2;
                const isDominant1 = (score1 === 6 && score2 <= 1);
                const isDominant2 = (score2 === 6 && score1 <= 1);

                const updatePlayer = (name, isWinner, gameDiff, mmrChangeVal, isCloseGame, isDominantGame) => {
                    if (!players[name]) return;
                    players[name].totalSets++;
                    players[name].gameDiff += gameDiff;
                    players[name].mmr += mmrChangeVal;
                    players[name].seasonMMRIncrease += mmrChangeVal;
                    if (isWinner) {
                        players[name].wins++;
                        if (!roundWins[name]) roundWins[name] = 0;
                        roundWins[name]++;
                        if (isCloseGame) players[name].closeWins++;
                    } else {
                        players[name].losses++;
                        if (isCloseGame) players[name].closeLosses++;
                    }
                    if (isCloseGame) {
                        players[name].closeSets++;
                    }
                    if (isDominantGame && isWinner) players[name].dominantWins++;
                };

                updatePlayer(p1, actual1, score1 - score2, mmrChange1, isClose, isDominant1);
                updatePlayer(p2, actual1, score1 - score2, mmrChange2, isClose, isDominant1);
                updatePlayer(p3, 1 - actual1, score2 - score1, mmrChange3, isClose, isDominant2);
                updatePlayer(p4, 1 - actual1, score2 - score1, mmrChange4, isClose, isDominant2);

                const updatePartnerStats = (player, partner, isWin, gameDiff) => {
                    if (!players[player] || !players[partner]) return;
                    if (!partnerStats[player]) partnerStats[player] = {};
                    if (!partnerStats[player][partner]) {
                        partnerStats[player][partner] = { wins: 0, losses: 0, gameDiffSum: 0, matches: 0 };
                    }
                    const stats = partnerStats[player][partner];
                    stats.matches++;
                    stats.gameDiffSum += gameDiff;
                    if (isWin) stats.wins++; else stats.losses++;
                };

                if (actual1 > 0) {
                    updatePartnerStats(p1, p2, true, score1 - score2);
                    updatePartnerStats(p2, p1, true, score1 - score2);
                    updatePartnerStats(p3, p4, false, score2 - score1);
                    updatePartnerStats(p4, p3, false, score2 - score1);
                } else {
                    updatePartnerStats(p1, p2, false, score1 - score2);
                    updatePartnerStats(p2, p1, false, score1 - score2);
                    updatePartnerStats(p3, p4, true, score2 - score1);
                    updatePartnerStats(p4, p3, true, score2 - score1);
                }
            });

            Object.keys(roundWins).forEach(pName => {
                if (roundWins[pName] === 3 && players[pName]) {
                    const isMalePlayer = !players[pName].isFemale;
                    const isMixedTeamPlayer = roundHasMixedMatch && !isMalePlayer;
                    if ((isMalePlayer && roundHasMixedMatch) || isMixedTeamPlayer) {
                        // 우승 제외
                    } else {
                        players[pName].championships++;
                    }
                }
            });
        });

        let sortedPlayers = Object.values(players).sort((a, b) => b.mmr - a.mmr);
        if (currentFilter === 'male') sortedPlayers = sortedPlayers.filter(p => !p.isFemale);
        else if (currentFilter === 'female') sortedPlayers = sortedPlayers.filter(p => p.isFemale);

        // MMR 히스토리 저장
        try {
            const historyDocRef = doc(db, 'league', 'data', 'mmrHistory', 'v1');
            const historyDocSnap = await getDoc(historyDocRef);
            const existingHistory = historyDocSnap.exists() ? historyDocSnap.data().snapshots || [] : [];
            const newSnapshot = { 
                game: existingHistory.length + 1,
                createdAt: new Date().toISOString()
            };
            sortedPlayers.forEach(p => {
                if (p.wins > 0 || p.losses > 0) {
                    const cleanName = p.name.replace(/[@.*]+/g, '_').replace(/_+/g, '_').trim();
                    newSnapshot[cleanName] = Math.round(p.mmr);
                }
            });
            console.log("newSnapshot:", newSnapshot);
            if (Object.keys(newSnapshot).length > 1) {
                existingHistory.push(newSnapshot);
                await setDoc(historyDocRef, { snapshots: existingHistory });
                console.log("MMR 히스토리 저장 완료:", newSnapshot);
            } else {
                console.warn("MMR 히스토리 스냅샷 데이터 부족:", newSnapshot);
                showToast("MMR 히스토리 데이터 부족!");
            }
        } catch (e) {
            console.error("MMR 히스토리 저장 중 오류:", e.message);
            showToast(`MMR 히스토리 저장 실패: ${e.message}`);
        }

        // 랭킹 테이블 업데이트
        const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
        rankingRows.forEach((row, index) => {
            const player = sortedPlayers[index];
            if (player) {
                player.avgGameDiff = player.totalSets > 0 ? (player.gameDiff / player.totalSets).toFixed(1) : '0.0';
                const currentRank = index + 1;
                const previousRank = previousRankings[player.name] || currentRank;
                const rankChange = previousRank - currentRank;
                let rankChangeText = '';
                let rankChangeClass = 'rank-nochange';
                if (rankChange > 0) {
                    rankChangeText = `↑${rankChange}`;
                    rankChangeClass = 'rank-up';
                } else if (rankChange < 0) {
                    rankChangeText = `↓${Math.abs(rankChange)}`;
                    rankChangeClass = 'rank-down';
                } else {
                    rankChangeText = '–';
                }

                row.cells[0].innerHTML = `${currentRank}<span class="rank-change ${rankChangeClass}">${rankChangeText}</span>`;
                row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                row.querySelector('.mmr').value = Math.round(player.mmr);
                row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                const champStar = row.querySelector('.championship-star');
                champStar.dataset.count = player.championships;
                champStar.textContent = '⭐'.repeat(player.championships);
                row.querySelector('.wins').value = player.wins;
                row.querySelector('.losses').value = player.losses;
                row.querySelector('.avg-game-diff').value = player.avgGameDiff;
                row.querySelector('.close-rate').value = player.totalSets >= 2 ? (player.closeSets === 0 ? '0' : Math.round(player.closeSets / player.totalSets * 100)) : '0';
                row.querySelector('.dominant-wins').value = player.totalSets > 0 ? Math.round(player.dominantWins / player.totalSets * 100) : '0';
                
                let bestPartner = { name: '-', score: -Infinity };
                let worstPartner = { name: '-', score: Infinity };
                if (partnerStats[player.name]) {
                    for (const partnerName in partnerStats[player.name]) {
                        if (partnerName === MANDATORY_PLAYER) continue;
                        const stats = partnerStats[player.name][partnerName];
                        if (stats.matches < 2) continue;
                        const winRate = stats.matches > 0 ? stats.wins / stats.matches : 0;
                        const avgGameDiff = stats.matches > 0 ? stats.gameDiffSum / stats.matches : 0;
                        const chemistryScore = (winRate * 70) + (avgGameDiff * 3);
                        if (chemistryScore > bestPartner.score) { bestPartner = { name: partnerName, score: chemistryScore }; }
                        if (chemistryScore < worstPartner.score) { worstPartner = { name: partnerName, score: chemistryScore }; }
                    }
                }
                row.querySelector('.best-partner').value = bestPartner.name.replace(/\*/g, '');
                row.querySelector('.worst-partner').value = worstPartner.name.replace(/\*/g, '');
            } else {
                row.cells[0].innerHTML = `${index + 1}<span class="rank-change rank-nochange">–</span>`;
                row.querySelectorAll('input:not([type=button])').forEach(input => input.value = '');
                row.querySelector('.championship-star').textContent = '';
            }
        });

        await saveRankings();
        showToast('순위 업데이트 완료!');
    }

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
        } else {
            console.warn("theme-toggle 요소 없음!");
        }
        localStorage.setItem('theme', theme);
    }

    function shareOnKakao() {
        console.log("카카오톡 공유 기능 호출");
        // 형의 원본 카카오 공유 로직 삽입 필요
    }

    function downloadCSV() {
        let rankingCSV = '\uFEFF순위,선수,MMR,우승,승,패,경기당 평균 게임 득실,접전률(%),압도승률(%),최고 파트ner,최하 파트ner\n';
        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const player = rawName.replace(/\*/g, '');
            if (player) {
                const rank = row.cells[0].textContent.split(' ')[0];
                const mmr = row.querySelector('.mmr').value;
                const championships = row.querySelector('.championship-star')?.dataset.count || '0';
                const wins = row.querySelector('.wins').value;
                const losses = row.querySelector('.losses').value;
                const avgGameDiff = row.querySelector('.avg-game-diff').value;
                const closeRate = row.querySelector('.close-rate').value;
                const dominantWins = row.querySelector('.dominant-wins').value;
                const bestPartner = row.querySelector('.best-partner').value;
                const worstPartner = row.querySelector('.worst-partner').value;
                rankingCSV += `${rank},"${player}",${mmr},${championships},${wins},${losses},${avgGameDiff},${closeRate},${dominantWins},"${bestPartner}","${worstPartner}"\n`;
            }
        });

        const blob = new Blob([rankingCSV], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'raelangaros_rankings.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function setupInputListeners() {
        const saveScheduleBtn = document.getElementById('save-schedule');
        const saveMatchesBtn = document.getElementById('save-matches');
        const saveRankingsBtn = document.getElementById('save-rankings');
        const updateRankingBtn = document.getElementById('update-ranking');
        const toggleRankingsBtn = document.getElementById('toggle-rankings');
        if (!saveScheduleBtn || !saveMatchesBtn || !saveRankingsBtn || !updateRankingBtn || !toggleRankingsBtn) {
            console.warn("저장 버튼 요소 없음!");
            showToast("버튼 로드 실패!");
            return;
        }
        saveScheduleBtn.addEventListener('click', saveSchedule);
        saveMatchesBtn.addEventListener('click', saveMatches);
        saveRankingsBtn.addEventListener('click', saveRankings);
        updateRankingBtn.addEventListener('click', updateRanking);
        toggleRankingsBtn.addEventListener('click', () => {
            const lowerRanks = document.querySelectorAll('.lower-rank');
            const isVisible = lowerRanks[0]?.classList.contains('show');
            lowerRanks.forEach(row => row.classList.toggle('show'));
            toggleRankingsBtn.textContent = isVisible ? '더보기' : '접기';
        });

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                updateRanking();
            });
        });
    }

    function waitForElements(selector, callback, retries = 10, delay = 100) {
        let attempts = 0;
        function check() {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0 && document.getElementById('schedule-container') && document.querySelector('#ranking-table tbody')) {
                console.log("DOM 요소 준비 완료:", selector);
                callback();
            } else if (attempts < retries) {
                attempts++;
                console.log(`DOM 요소 대기 중 (${attempts}/${retries})...`);
                setTimeout(check, delay);
            } else {
                console.error("DOM 요소 로드 실패:", selector);
                showToast("페이지 로드 오류!");
            }
        }
        check();
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded 이벤트 실행");
        waitForElements('#schedule-container, #ranking-table tbody', () => {
            applyTheme(localStorage.getItem('theme') || 'dark');
            createScheduleRounds();
            createRankingRows();
            if (db) {
                loadData();
            } else {
                console.warn("DB 연결 없음!");
                showToast("DB 연결 실패!");
            }
            setupInputListeners();
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
            }
            const kakaoShareBtn = document.getElementById('kakao-share-btn');
            if (kakaoShareBtn) {
                kakaoShareBtn.addEventListener('click', shareOnKakao);
            }
            const downloadCsvBtn = document.getElementById('download-csv');
            if (downloadCsvBtn) {
                downloadCsvBtn.addEventListener('click', downloadCSV);
            }
            console.log("이벤트 리스너 설정 완료!");
        });
    });
</script>
</body>
</html>