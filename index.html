<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 래랑가로스</title>
    <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js" integrity="sha384-y3tIif2B4242xI/mS8d43/p/a1uBoL3w7sL2rS4z0nBjwA/2/g8L/DTrb1JScC4k" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 15px; transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1100px; margin: 0 auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; font-weight: 900; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding-top: 20px; margin-bottom: 2rem; letter-spacing: -2px; text-shadow: 2px 2px 10px var(--shadow-color); }
        .section { background: var(--surface-color); padding: 20px; border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 2.5rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 1.8rem; font-weight: 700; color: var(--primary-color); margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        details { margin-bottom: 1rem; border-radius: 8px; overflow: hidden; border: 1px solid var(--border-color); }
        details summary { padding: 12px 15px; cursor: pointer; font-size: 1.1rem; font-weight: 700; outline: none; transition: background 0.3s ease, color 0.3s ease; background: linear-gradient(135deg, #2a2a2a, #222222); color: var(--secondary-color); }
        html[data-theme="light"] details summary { background: linear-gradient(135deg, #f9f9f9, #f1f1f1); color: var(--text-color); }
        details[open] > summary { background: var(--primary-color); color: var(--bg-color); }
        html[data-theme="light"] details[open] > summary { color: var(--secondary-color); }
        .round-group-content { padding: 15px 10px 5px 10px; background: rgba(0,0,0,0.1); border-top: 1px solid var(--border-color); }
        html[data-theme="light"] .round-group-content { background: rgba(0,0,0,0.02); }
        .table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        table { width: 100%; min-width: 600px; border-collapse: collapse; }
        th, td { padding: 12px 10px; text-align: center; border-bottom: 1px solid var(--border-color); font-size: 0.9rem; white-space: nowrap; }
        th { font-family: 'Poppins', sans-serif; background-color: rgba(0, 0, 0, 0.2); color: var(--primary-variant-color); font-weight: 700; }
        html[data-theme="light"] th { background-color: #F9FAFB; }
        input[type="text"] { width: 100%; min-width: 80px; padding: 8px; background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; color: var(--text-color); font-family: 'Noto Sans KR', sans-serif; text-align: center; }
        input[type="text"].readonly { background-color: #252525; color: var(--text-secondary-color); font-weight: bold; }
        html[data-theme="light"] input[type="text"].readonly { background-color: #f0f0f0; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .btn { display: inline-block; padding: 12px 20px; background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1rem; border: none; text-align: center; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .update-btn { width: 100%; margin-top: 20px; padding: 15px; background: linear-gradient(135deg, var(--accent-gold), #F5B02E); color: var(--bg-color); border: none; border-radius: 8px; font-size: 1.2rem; font-weight: 900; cursor: pointer; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #333, #111); color: #fff; padding: 12px 25px; border-radius: 50px; box-shadow: 0 5px 15px var(--shadow-color); opacity: 0; transition: opacity 0.4s, transform 0.4s; font-weight: 700; z-index: 1000; }
        .toast.show { opacity: 1; }
        .championship-star { color: var(--accent-gold); text-shadow: 0 0 5px var(--accent-gold); font-size: 1.1rem; font-weight: 900; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1>2025 래랑가로스</h1>
        <div class="section">
            <h2>경기 일정</h2>
            <div id="schedule-container"></div>
            <button id="update-ranking" class="update-btn">순위 업데이트</button>
        </div>
        <div class="section">
            <h2>시즌 순위표</h2>
            <div class="table-wrapper">
                <table id="ranking-table">
                    <thead><tr><th>순위</th><th>선수</th><th>MMR</th><th>우승</th><th>승</th><th>패</th><th>게임득실</th><th>접전승률(%)</th><th>압도승률(%)</th><th>최고 파트너</th><th>최하 파트너</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="btn-group">
                <a href="dash.html" class="btn" id="dashboard-link">통계 대시보드</a>
                <button id="kakao-share-btn" class="btn">카카오톡 공유</button>
                <button id="download-csv" class="btn">CSV 다운로드</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
    
    const firebaseConfig = { apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", authDomain: "tennis-plan-jibung.firebaseapp.com", projectId: "tennis-plan-jibung", storageBucket: "tennis-plan-jibung.appspot.com", messagingSenderId: "491083537160", appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" };
    
    let db;
    try {
        db = getFirestore(initializeApp(firebaseConfig));
    } catch (e) { console.error(e); }

    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }

function createScheduleRounds() {
    const container = document.getElementById('schedule-container');
    let roundsHtml = '';
    for (let group = 0; group < 6; group++) {
        const startRound = group * 10 + 1;
        const endRound = (group + 1) * 10;
        roundsHtml += `<details class="round-group"><summary>${startRound} ~ ${endRound}회차</summary><div class="round-group-content">`;
        for (let i = startRound; i <= endRound; i++) {
            roundsHtml += `
            <details>
                <summary>${i}회차</summary>
                <div class="table-wrapper">
                    <table class="schedule-table" data-round-id="${i}">
                        <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                        <tbody>
                            <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                            <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                            <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="6-4" class="score"></td></tr>
                        </tbody>
                    </table>
                </div>
            </details>`;
        }
        roundsHtml += `</div></details>`;
    }
    container.innerHTML = roundsHtml;
}
    
    function createRankingRows() {
        const rankingBody = document.querySelector('#ranking-table tbody');
        let rowsHtml = '';
        for (let i = 1; i <= 30; i++) {
            rowsHtml += `
            <tr>
                <td class="rank-cell">${i}</td><td><input type="text" placeholder="선수 ${i}" class="ranking-player"></td><td><input type="text" class="mmr readonly" readonly></td><td><span class="championship-star"></span></td><td><input type="text" class="wins readonly" readonly></td><td><input type="text" class="losses readonly" readonly></td><td><input type="text" class="game-diff readonly" readonly></td><td><input type="text" class="close-wins readonly" readonly></td><td><input type="text" class="dominant-wins readonly" readonly></td><td><input type="text" class="best-partner readonly" readonly></td><td><input type="text" class="worst-partner readonly" readonly></td>
            </tr>`;
        }
        rankingBody.innerHTML = rowsHtml;
    }

    async function saveData() {
        if (!db) return showToast('DB 연결 실패');
        try {
            const scheduleRows = document.querySelectorAll('.schedule-table tbody tr');
            const scheduleData = Array.from(scheduleRows).map(row => ({ player1: row.querySelector('.player1').value.trim(), player2: row.querySelector('.player2').value.trim(), player3: row.querySelector('.player3').value.trim(), player4: row.querySelector('.player4').value.trim(), score: row.querySelector('.score').value.trim() }));
            await setDoc(doc(db, 'league', 'data', 'schedule', 'v1'), { matches: scheduleData });

            const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
            const rankingData = Array.from(rankingRows).map(row => ({
                name: row.querySelector('.ranking-player').value.trim().replace('*', ''),
                mmr: row.querySelector('.mmr').value || '0', 
                championships: row.querySelector('.championship-star')?.dataset.count || '0', 
                wins: row.querySelector('.wins').value || '0', 
                losses: row.querySelector('.losses').value || '0', 
                gameDiff: row.querySelector('.game-diff').value || '0', 
            })).filter(player => player.name);
            await setDoc(doc(db, 'league', 'data', 'rankings', 'v1'), { players: rankingData });
        } catch (e) { console.error("Save failed:", e); showToast(`저장 실패: ${e.message}`); }
    }

    async function loadData() {
        if (!db) return;
        try {
            const scheduleDoc = await getDoc(doc(db, 'league', 'data', 'schedule', 'v1'));
            if (scheduleDoc.exists()) {
                const scheduleData = scheduleDoc.data().matches || [];
                document.querySelectorAll('.schedule-table tbody tr').forEach((row, index) => {
                    if (scheduleData[index]) {
                        row.querySelector('.player1').value = scheduleData[index].player1 || '';
                        row.querySelector('.player2').value = scheduleData[index].player2 || '';
                        row.querySelector('.player3').value = scheduleData[index].player3 || '';
                        row.querySelector('.player4').value = scheduleData[index].player4 || '';
                        row.querySelector('.score').value = scheduleData[index].score || '';
                    }
                });
            }
            const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            if (rankingDoc.exists()) {
                const rankingData = rankingDoc.data().players || [];
                document.querySelectorAll('#ranking-table tbody tr').forEach((row, index) => {
                     const player = rankingData[index];
                     if (player) {
                        row.querySelector('.ranking-player').value = player.name || '';
                        row.querySelector('.mmr').value = player.mmr || '0';
                        const champStar = row.querySelector('.championship-star');
                        champStar.dataset.count = player.championships || '0';
                        champStar.textContent = '⭐'.repeat(parseInt(player.championships) || 0);
                        row.querySelector('.wins').value = player.wins || '0';
                        row.querySelector('.losses').value = player.losses || '0';
                        row.querySelector('.game-diff').value = player.gameDiff || '0';
                     }
                });
            }
        } catch(e) { console.error("Load failed:", e); showToast("데이터 로드 실패: " + e.message); }
    }

async function updateRanking() {
    const BASE_MMR = 1500;
    const K_FACTOR = 32;
    const HANDICAP_BASE_POINT = 1500;
    const HANDICAP_ZERO_POINT = 1650;
    const HANDICAP_MAX = 150;

    const players = {};
    const partnerStats = {};

    document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
        const name = row.querySelector('.ranking-player').value.trim();
        if (name) {
            players[name] = { name, wins: 0, losses: 0, gameDiff: 0, mmr: BASE_MMR, championships: 0, closeWins: 0, closeSets: 0, dominantWins: 0, totalSets: 0 };
            partnerStats[name] = {};
        }
    });

    const scheduleTables = document.querySelectorAll('.schedule-table');
    scheduleTables.forEach((table) => {
        let roundHasMixedMatch = false;
        const rows = table.querySelectorAll('tbody tr');
        let roundWins = {};

        rows.forEach(row => {
            const p1 = row.querySelector('.player1').value.trim();
            const p2 = row.querySelector('.player2').value.trim();
            const p3 = row.querySelector('.player3').value.trim();
            const p4 = row.querySelector('.player4').value.trim();
            const score = row.querySelector('.score').value.trim();

            if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;

            [p1, p2, p3, p4].forEach(p => {
                if (p && !players[p]) {
                    players[p] = { name: p, wins: 0, losses: 0, gameDiff: 0, mmr: BASE_MMR, championships: 0, closeWins: 0, closeSets: 0, dominantWins: 0, totalSets: 0 };
                    partnerStats[p] = {};
                }
            });

            const team1IsMixed = (p1.includes('*') && !p2.includes('*')) || (!p1.includes('*') && p2.includes('*')) || (p1.includes('*') && p2.includes('*'));
            const team2IsMixed = (p3.includes('*') && !p4.includes('*')) || (!p3.includes('*') && p4.includes('*')) || (p3.includes('*') && p4.includes('*'));

            if (team1IsMixed || team2IsMixed) {
                roundHasMixedMatch = true;
            }

            const getDynamicHandicap = (mmr) => {
                if (mmr >= HANDICAP_ZERO_POINT) return 0;
                if (mmr <= HANDICAP_BASE_POINT) return HANDICAP_MAX;
                const progress = (mmr - HANDICAP_BASE_POINT) / (HANDICAP_ZERO_POINT - HANDICAP_BASE_POINT);
                return Math.max(0, HANDICAP_MAX * (1 - progress));
            };

            let team1MMR = (players[p1].mmr + players[p2].mmr) / 2;
            let team2MMR = (players[p3].mmr + players[p4].mmr) / 2;
            let effectiveTeam1MMR = team1MMR;
            let effectiveTeam2MMR = team2MMR;

            if (team1IsMixed) {
                let handicap = 0;
                if (p1.includes('*')) handicap += getDynamicHandicap(players[p1].mmr);
                if (p2.includes('*')) handicap += getDynamicHandicap(players[p2].mmr);
                effectiveTeam1MMR += handicap / (p1.includes('*') && p2.includes('*') ? 2 : 1);
                effectiveTeam1MMR *= 1.5; // 50% 가중치 추가
            }
            if (team2IsMixed) {
                let handicap = 0;
                if (p3.includes('*')) handicap += getDynamicHandicap(players[p3].mmr);
                if (p4.includes('*')) handicap += getDynamicHandicap(players[p4].mmr);
                effectiveTeam2MMR += handicap / (p3.includes('*') && p4.includes('*') ? 2 : 1);
                effectiveTeam2MMR *= 1.5; // 50% 가중치 추가
            }

            const expected1 = 1 / (1 + Math.pow(10, (effectiveTeam2MMR - effectiveTeam1MMR) / 400));
            const [score1, score2] = score.split('-').map(Number);
            const actual1 = score1 > score2 ? 1 : 0;
            const mmrChange = K_FACTOR * (actual1 - expected1);

            const isClose = Math.abs(score1 - score2) <= 2;
            const isDominant1 = !team1IsMixed && !team2IsMixed && score1 === 6 && score2 <= 1; // 혼성팀 제외
            const isDominant2 = !team1IsMixed && !team2IsMixed && score2 === 6 && score1 <= 1; // 혼성팀 제외

            const updatePlayer = (name, isWinner, gameDiff, mmrChangeVal, isCloseGame, isDominantGame) => {
                if (!players[name]) return;
                players[name].totalSets++;
                players[name].gameDiff += gameDiff;
                players[name].mmr += mmrChangeVal;
                if (isWinner) {
                    players[name].wins++;
                    if (!roundWins[name]) roundWins[name] = 0;
                    roundWins[name]++;
                } else {
                    players[name].losses++;
                }
                if (isCloseGame) {
                    players[name].closeSets++;
                    if (isWinner) players[name].closeWins++;
                }
                if (isDominantGame && isWinner) players[name].dominantWins++;
            };

            updatePlayer(p1, actual1, score1 - score2, mmrChange, isClose, isDominant1);
            updatePlayer(p2, actual1, score1 - score2, mmrChange, isClose, isDominant1);
            updatePlayer(p3, 1 - actual1, score2 - score1, -mmrChange, isClose, isDominant2);
            updatePlayer(p4, 1 - actual1, score2 - score1, -mmrChange, isClose, isDominant2);

            const updatePartnerStats = (player, partner, isWin, gameDiff) => {
                if (!players[player] || !players[partner]) return;
                if (!partnerStats[player]) partnerStats[player] = {};
                if (!partnerStats[player][partner]) {
                    partnerStats[player][partner] = { wins: 0, losses: 0, gameDiffSum: 0, matches: 0 };
                }
                const stats = partnerStats[player][partner];
                stats.matches++;
                stats.gameDiffSum += gameDiff;
                if (isWin) stats.wins++; else stats.losses++;
            };

            if (actual1 > 0) {
                updatePartnerStats(p1, p2, true, score1 - score2);
                updatePartnerStats(p2, p1, true, score1 - score2);
                updatePartnerStats(p3, p4, false, score2 - score1);
                updatePartnerStats(p4, p3, false, score2 - score1);
            } else {
                updatePartnerStats(p1, p2, false, score1 - score2);
                updatePartnerStats(p2, p1, false, score1 - score2);
                updatePartnerStats(p3, p4, true, score2 - score1);
                updatePartnerStats(p4, p3, true, score2 - score1);
            }
        });

        Object.keys(roundWins).forEach(pName => {
            if (roundWins[pName] === 3 && players[pName]) {
                const isMalePlayer = !pName.includes('*');
                const isMixedTeamPlayer = roundHasMixedMatch && !isMalePlayer;
                if ((isMalePlayer && roundHasMixedMatch) || isMixedTeamPlayer) {
                    // 남성2 vs 남자1+여자1 회차에서 우승 제외
                } else {
                    players[pName].championships++;
                }
            }
        });
    });

    const sortedPlayers = Object.values(players).sort((a, b) => b.mmr - a.mmr);

    try {
        const historyDocRef = doc(db, 'league', 'data', 'mmrHistory', 'v1');
        const historyDocSnap = await getDoc(historyDocRef);
        const existingHistory = historyDocSnap.exists() ? historyDocSnap.data().snapshots || [] : [];
        const newSnapshot = {
            game: existingHistory.length + 1,
            createdAt: serverTimestamp()
        };
        sortedPlayers.forEach(p => {
            if (p.wins > 0 || p.losses > 0) {
                newSnapshot[p.name.replace('*', '').replace(/\./g, '_')] = Math.round(p.mmr);
            }
        });
        if (Object.keys(newSnapshot).length > 2) {
            existingHistory.push(newSnapshot);
            await setDoc(historyDocRef, { snapshots: existingHistory });
        }
    } catch (e) { console.error("MMR 히스토리 저장 중 오류:", e); }

    const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
    rankingRows.forEach((row, index) => {
        const player = sortedPlayers[index];
        if (player) {
            row.cells[0].textContent = index + 1;
            row.querySelector('.ranking-player').value = player.name;
            row.querySelector('.mmr').value = Math.round(player.mmr);
            const champStar = row.querySelector('.championship-star');
            champStar.dataset.count = player.championships;
            champStar.textContent = '⭐'.repeat(player.championships);
            row.querySelector('.wins').value = player.wins;
            row.querySelector('.losses').value = player.losses;
            row.querySelector('.game-diff').value = player.gameDiff;
            row.querySelector('.close-wins').value = player.closeSets > 0 ? Math.round(player.closeWins / player.closeSets * 100) : 'N/A';
            row.querySelector('.dominant-wins').value = player.totalSets > 0 ? Math.round(player.dominantWins / player.totalSets * 100) : 'N/A';

            let bestPartner = { name: '-', score: -Infinity };
            let worstPartner = { name: '-', score: Infinity };
            if (partnerStats[player.name]) {
                for (const partnerName in partnerStats[player.name]) {
                    const stats = partnerStats[player.name][partnerName];
                    const winRate = stats.matches > 0 ? stats.wins / stats.matches : 0;
                    const avgGameDiff = stats.matches > 0 ? stats.gameDiffSum / stats.matches : 0;
                    const chemistryScore = (winRate * 70) + (avgGameDiff * 3);
                    if (chemistryScore > bestPartner.score) { bestPartner = { name: partnerName, score: chemistryScore }; }
                    if (chemistryScore < worstPartner.score) { worstPartner = { name: partnerName, score: chemistryScore }; }
                }
            }
            row.querySelector('.best-partner').value = bestPartner.name.replace('*', '');
            row.querySelector('.worst-partner').value = worstPartner.name.replace('*', '');
        } else {
            row.cells[0].textContent = index + 1;
            row.querySelectorAll('input:not([type=button])').forEach(input => input.value = '');
            row.querySelector('.championship-star').textContent = '';
        }
    });

    await saveData();
    showToast('순위 업데이트 완료!');
}
    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        document.getElementById('theme-toggle').textContent = theme === 'dark' ? '☀️' : '🌙';
        localStorage.setItem('theme', theme);
    }

    function shareOnKakao() { /* 카카오 공유 로직 */ }
    
    function downloadCSV() {
        let rankingCSV = '\uFEFF순위,선수,MMR,우승,승,패,게임득실,접전승률(%),압도승률(%),최고 파트너,최하 파트너\n';
        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const player = row.querySelector('.ranking-player').value.replace('*', '');
            if(player) {
                const rank = row.cells[0].textContent;
                const mmr = row.querySelector('.mmr').value;
                const championships = row.querySelector('.championship-star')?.dataset.count || '0';
                const wins = row.querySelector('.wins').value;
                const losses = row.querySelector('.losses').value;
                const gameDiff = row.querySelector('.game-diff').value;
                const closeWins = row.querySelector('.close-wins').value;
                const dominantWins = row.querySelector('.dominant-wins').value;
                const bestPartner = row.querySelector('.best-partner').value;
                const worstPartner = row.querySelector('.worst-partner').value;
                rankingCSV += `<span class="math-inline">\{rank\},"</span>{player}",<span class="math-inline">\{mmr\},</span>{championships},<span class="math-inline">\{wins\},</span>{losses},<span class="math-inline">\{gameDiff\},</span>{closeWins},<span class="math-inline">\{dominantWins\},"</span>{bestPartner}","${worstPartner}"\n`;
            }
        });
        
        const blob = new Blob([rankingCSV], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'raelangaros_rankings.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    function setupInputListeners() {
        document.querySelectorAll('#schedule-container input, #ranking-table .ranking-player').forEach(input => {
            input.addEventListener('change', saveData);
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        applyTheme(localStorage.getItem('theme') || 'dark');
        createScheduleRounds();
        createRankingRows();
        if (db) {
            loadData();
            setupInputListeners();
        }
        document.getElementById('theme-toggle').addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
        document.getElementById('update-ranking').addEventListener('click', updateRanking);
        document.getElementById('kakao-share-btn').addEventListener('click', shareOnKakao);
        document.getElementById('download-csv').addEventListener('click', downloadCSV);
    });
</script>
</body>
</html>
