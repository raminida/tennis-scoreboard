<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 ÎûòÎûëÍ∞ÄÎ°úÏä§ ÎåÄÏãúÎ≥¥Îìú</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; }
        .container { max-width: 960px; margin: auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding: 20px 0; margin-bottom: 3rem; letter-spacing: -2px; }
        .section { background: var(--surface-color); padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 3rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 2.2rem; color: var(--primary-color); margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        .charts-container { display: grid; grid-template-columns: 1fr; gap: 40px; margin-bottom: 40px; }
        .chart-control { margin-bottom: 20px; text-align: center; }
        .chart-control label { font-weight: bold; margin-right: 10px; }
        .chart-control select { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); background-color: var(--surface-color); color: var(--text-color); }
        .awards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; }
        .award-card { background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; text-align: center; }
        html[data-theme="light"] .award-card { background: #F9FAFB; }
        .award-icon { font-size: 3rem; margin-bottom: 10px; color: var(--accent-gold); }
        .award-title { font-family: 'Poppins', sans-serif; font-size: 1.3rem; color: var(--primary-variant-color); margin-bottom: 5px; }
        .award-winner { font-size: 1.1rem; font-weight: 700; color: var(--text-color); }
        .award-value { font-size: 0.9rem; color: var(--text-secondary-color); }
        .award-runner-up { font-size: 0.9rem; color: var(--text-secondary-color); margin-top: 5px; font-weight: 500; }
        .btn { display: inline-block; padding: 12px 28px; margin: 10px 5px; background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: 8px; font-weight: 700; border: none; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .theme-toggle { position: fixed; top: 20px; right: 20px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #333, #111);
            color: #fff;
            padding: 12px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 15px var(--shadow-color);
            opacity: 0;
            transition: opacity 0.4s, transform 0.4s;
            font-weight: 700;
            z-index: 1000;
        }
        html[data-theme="light"] .toast {
            background: linear-gradient(135deg, #f9f9f9, #f1f1f1);
            color: #333;
        }
        .toast.show {
            opacity: 1;
        }
        @media (max-width: 640px) { 
            body { padding: 15px; } 
            h1 { font-size: 2.2rem; } 
            h2 { font-size: 1.8rem; } 
            .section { padding: 20px; } 
            .awards-grid { grid-template-columns: 1fr; } 
        }
        #mmr-chart-container canvas {
            max-height: 600px;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">‚òÄÔ∏è</button>
    <div class="container">
        <h1>2025 ÎûòÎûëÍ∞ÄÎ°úÏä§ ÎåÄÏãúÎ≥¥Îìú</h1>
        <div class="section">
            <h2>ÌÜµÍ≥Ñ Ï∞®Ìä∏</h2>
            <div class="charts-container">
                <div id="mmr-chart-container">
                    <h3>TOP 5 MMR Ï∂îÏù¥</h3>
                    <canvas id="mmr-chart"></canvas>
                </div>
                <div>
                    <h3>ÏÑ†Ïàò Îä•Î†•Ïπò Î†àÏù¥Îçî</h3>
                    <div class="chart-control">
                        <label for="player-select">ÏÑ†Ïàò ÏÑ†ÌÉù:</label>
                        <select id="player-select"></select>
                    </div>
                    <canvas id="player-radar-chart"></canvas>
                </div>
            </div>
        </div>
        <div class="section">
            <h2>üèÜ ÏãúÏ¶å Ïñ¥ÏõåÎìú</h2>
            <div class="awards-grid"></div>
            <div style="text-align: center; margin-top: 30px;"><a href="index.html" class="btn">Î©îÏù∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</a></div>
        </div>
    </div>
<script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = { 
        apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", 
        authDomain: "tennis-plan-jibung.firebaseapp.com", 
        projectId: "tennis-plan-jibung", 
        storageBucket: "tennis-plan-jibung.appspot.com", 
        messagingSenderId: "491083537160", 
        appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" 
    };
    let db;
    try { 
        db = getFirestore(initializeApp(firebaseConfig)); 
    } catch (e) { 
        console.error("Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®:", e);
        showToast("Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®!");
    }

    let mmrChart, radarChart;
    let allPlayersData = [];
    let fullMmrHistory = [];

    const femalePlayersList = [
        "ÎÇ®Ï†ïÏ£º", "ÍπÄÏú†Ìïò", "ÏÑ±ÏòàÏßÑ", "ÌïúÌòúÎ†π", "Ï°∞ÏßÄÏòÅ", "Ïù¥ÏùÄÏßÄ", "Í≥†Í≤ΩÎ¶¨", "ÍπÄÎÇòÍ≤Ω", "ÍπÄÏßÄÏõê",
        "Ïù¥ÏßÄÌôî", "Ï†ïÏó∞Ìôî", "Ï∞®Í≤ΩÎ†®", "ÌïúÏ†ïÏïÑ", "Ïú†ÏãúÏó∞", "ÍπÄÏú†ÎØ∏", "Ïã†ÌòÑÏ†ï", "Ïù¥ÏòàÏùÄ", "Ïù¥ÏÑ†ÎØ∏",
        "Î∞ïÏÑ†Ïàô", "Î∞ïÏïÑÎ¶Ñ", "Ïù¥ÏïÑÎ¶Ñ", "ÏÑúÏú†ÎÇò", "ÌóàÏÑ†ÏòÅ", "ÏÜ°ÏùÄÏ£º", "Ïú°ÌïòÎÇò", "Ïù¥Í∞ÄÏòÅ", "Ïù¥Ïú†Îπà",
        "Ï†ïÌï¥ÏòÅ", "Ï°∞ÏàòÌù¨", "Ï°∞ÏïÑÌòÑ", "ÏµúÏ£ºÏó∞", "Ìô©ÏàòÏßÑ"
    ];

    function normalizePlayerName(name) {
        return name ? name.replace(/\*/g, '').trim().toLowerCase() : '';
    }

    function totalGames(player) {
        const wins = parseInt(player.wins || 0);
        const losses = parseInt(player.losses || 0);
        const games = wins + losses || 0;
        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Ï¥ù Í≤ΩÍ∏∞ Ïàò: ${games} (Ïäπ: ${wins}, Ìå®: ${losses})`);
        return games;
    }

    function isMixedTeam(player1, player2, allPlayersData) {
        const p1 = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(player1));
        const p2 = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(player2));
        if (!p1 || !p2) return false;
        return (p1.gender === 'M' && p2.gender === 'F') || (p1.gender === 'F' && p2.gender === 'M');
    }

    function isMaleTeam(player1, player2, allPlayersData) {
        const p1 = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(player1));
        const p2 = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(player2));
        return p1 && p2 && p1.gender === 'M' && p2.gender === 'M';
    }

    function calculateMMRChange(winner, loser, match, allPlayersData) {
        const baseMMRChange = 25;
        let multiplier = 1.0;

        const winnerIsMixed = isMixedTeam(match.winnerPlayer1, match.winnerPlayer2, allPlayersData);
        const loserIsMixed = isMixedTeam(match.loserPlayer1, match.loserPlayer2, allPlayersData);
        const winnerIsMale = isMaleTeam(match.winnerPlayer1, match.winnerPlayer2, allPlayersData);
        const loserIsMale = isMaleTeam(match.loserPlayer1, match.loserPlayer2, allPlayersData);

        if (winnerIsMixed && loserIsMale) {
            multiplier = 2.0;
            console.log(`ÌòºÏÑ±ÌåÄ(${winner})Ïù¥ ÎÇ®ÏûêÌåÄ(${loser}) Ïù¥ÍπÄ - MMR x${multiplier}`);
        } else if (winnerIsMale && loserIsMixed) {
            multiplier = 0.5;
            console.log(`ÎÇ®ÏûêÌåÄ(${winner})Ïù¥ ÌòºÏÑ±ÌåÄ(${loser}) Ïù¥ÍπÄ - MMR x${multiplier}`);
        } else {
            multiplier = 1.0;
            console.log(`ÏùºÎ∞ò Í≤ΩÍ∏∞(${winner} vs ${loser}) - MMR x${multiplier}`);
        }

        return Math.round(baseMMRChange * multiplier);
    }

    function setupPlayerSelector() {
        console.log("setupPlayerSelector Ìò∏Ï∂ú");
        const select = document.getElementById('player-select');
        if (!select) {
            console.error("player-select ÏöîÏÜå ÏóÜÏùå!");
            showToast("ÏÑ†Ïàò ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥ Ïò§Î•ò!");
            return;
        }
        select.innerHTML = '';
        allPlayersData.forEach(player => {
            const option = document.createElement('option');
            option.value = player.name;
            option.textContent = player.name;
            select.appendChild(option);
        });
        select.addEventListener('change', (e) => {
            console.log(`ÏÑ†Ïàò ÏÑ†ÌÉù: ${e.target.value}`);
            renderPlayerRadarChart(e.target.value);
        });
        console.log("ÏÑ†Ïàò ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥ ÏÑ§Ï†ï ÏôÑÎ£å!");
    }

    function renderPlayerRadarChart(playerName) {
        console.log(`renderPlayerRadarChart Ìò∏Ï∂ú: ${playerName}`);
        const player = allPlayersData.find(p => p.name === playerName);
        if (!player) {
            console.error(`ÌîåÎ†àÏù¥Ïñ¥ ${playerName} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!`);
            showToast(`ÌîåÎ†àÏù¥Ïñ¥ ${playerName} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!`);
            return;
        }

        const ctx = document.getElementById('player-radar-chart')?.getContext('2d');
        if (!ctx) {
            console.error("player-radar-chart Ï∫îÎ≤ÑÏä§ ÏóÜÏùå!");
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Ï∫îÎ≤ÑÏä§ Ïò§Î•ò!");
            return;
        }

        const playedPlayers = allPlayersData.filter(p => totalGames(p) >= 0);
        if (playedPlayers.length === 0) {
            console.error("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            return;
        }

        const getRank = (p, stat) => [...playedPlayers].sort((a,b) => (b[stat] || 0) - (a[stat] || 0)).findIndex(pl => pl.name === p.name) + 1;
        const getPercentileScore = (rank) => playedPlayers.length <= 1 ? 100 : Math.pow((playedPlayers.length - rank) / (playedPlayers.length - 1), 0.7) * 100;

        const mmrRank = getRank(player, 'mmr');
        const mmrScore = getPercentileScore(mmrRank);

        allPlayersData.forEach(p => p.winRate = totalGames(p) > 0 ? p.wins / totalGames(p) : 0);
        const winRateRank = getRank(player, 'winRate');
        const winRateScore = getPercentileScore(winRateRank);

        const totalGamesPlayed = totalGames(player);
        allPlayersData.forEach(p => p.avgGameDiff = totalGames(p) > 0 ? (p.gameDiff || 0) / totalGames(p) : 0);
        const avgGameDiffRank = getRank(player, 'avgGameDiff');
        const avgGameDiffScore = getPercentileScore(avgGameDiffRank);

        allPlayersData.forEach(p => p.dominantRate = parseFloat(p.dominantWins || 0));
        const dominantRank = getRank(player, 'dominantRate');
        const dominantScore = getPercentileScore(dominantRank);

        const playerMmrHistory = fullMmrHistory.map(h => h[playerName.replace(/\*/g, '').replace(/\./g, '_')]).filter(mmr => mmr !== undefined);
        let consistencyScore = 0;
        if (playerMmrHistory.length < 2 || playerMmrHistory.every((v, i, a) => !i || v >= a[i-1])) {
            consistencyScore = 100;
        } else {
            const mean = playerMmrHistory.reduce((a, b) => a + b, 0) / playerMmrHistory.length;
            const stddev = Math.sqrt(playerMmrHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / playerMmrHistory.length);
            consistencyScore = Math.max(0, 100 - (stddev * 2));
        }

        allPlayersData.forEach(p => p.avgPointsPerGame = totalGames(p) > 0 ? (parseInt(p.totalPoints || 0) / totalGames(p)) : 0);
        const pointsRank = getRank(player, 'avgPointsPerGame');
        const pointsScore = getPercentileScore(pointsRank);

        const data = {
            labels: ['MMR', 'ÏäπÎ•†', 'ÌèâÍ∑† Í≤åÏûÑÎìùÏã§', 'ÏïïÎèÑÎ†•', 'Íæ∏Ï§ÄÌï®', 'ÌèâÍ∑† Ìè¨Ïù∏Ìä∏'],
            datasets: [{
                label: player.name,
                data: [ mmrScore, winRateScore, avgGameDiffScore, dominantScore, consistencyScore, pointsScore ],
                backgroundColor: 'rgba(76, 175, 80, 0.2)',
                borderColor: 'rgba(76, 175, 80, 1)',
                pointBackgroundColor: 'rgba(76, 175, 80, 1)',
            }]
        };

        if (radarChart) radarChart.destroy();

        const radarOptions = {
            elements: { line: { borderWidth: 3 } },
            scales: {
                r: {
                    angleLines: { color: 'var(--border-color)' },
                    grid: { color: 'var(--border-color)' },
                    pointLabels: { font: { size: 14 }, color: 'var(--text-color)' },
                    ticks: {
                        display: true,
                        stepSize: 20,
                        backdropColor: 'transparent',
                        color: 'var(--text-secondary-color)'
                    },
                    min: 0,
                    max: 100
                }
            },
            plugins: { legend: { labels: { color: 'var(--text-color)', font: { size: 16 } } } }
        };

        try {
            radarChart = new Chart(ctx, { type: 'radar', data: data, options: radarOptions });
            console.log(`Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏôÑÎ£å: ${playerName}`);
        } catch (error) {
            console.error("Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏóêÎü¨:", error.message);
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ Ïã§Ìå®!");
        }
    }

    function renderMmrChart(history, topPlayers, useWinRate = false, matchesData = []) {
        console.log("renderMmrChart Ìò∏Ï∂ú");
        const ctx = document.getElementById('mmr-chart')?.getContext('2d');
        if (!ctx) {
            console.error("mmr-chart Ï∫îÎ≤ÑÏä§ ÏóÜÏùå!");
            showToast("Í∑∏ÎûòÌîÑ Ï∫îÎ≤ÑÏä§ Ïò§Î•ò!");
            return;
        }

        if (!topPlayers || topPlayers.length === 0) {
            console.error("TOP ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå:", topPlayers);
            showToast("TOP ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            return;
        }

        const chartContainer = document.getElementById('mmr-chart-container');
        const titleElement = chartContainer?.querySelector('h3');
        if (titleElement) {
            titleElement.textContent = useWinRate ? "TOP 5 ÏäπÎ•† Ï∂îÏù¥" : "TOP 5 MMR Ï∂îÏù¥";
        } else {
            console.warn("MMR Í∑∏ÎûòÌîÑ Ï†úÎ™©(h3) ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå!");
            showToast("MMR Í∑∏ÎûòÌîÑ Ï†úÎ™© Ïò§Î•ò!");
        }

        let datasets, labels, yAxisConfig;
        if (useWinRate) {
            const winRateHistory = [];
            let maxGames = 0;
            topPlayers.forEach(name => {
                const player = allPlayersData.find(p => p.name === name);
                if (player) {
                    const totalGamesPlayed = totalGames(player);
                    maxGames = Math.max(maxGames, totalGamesPlayed);
                }
            });

            for (let i = 1; i <= Math.min(maxGames, 6); i++) {
                const snapshot = { round: i };
                topPlayers.forEach(name => {
                    const player = allPlayersData.find(p => p.name === name);
                    if (player) {
                        const wins = parseInt(player.wins || 0);
                        const losses = parseInt(player.losses || 0);
                        const gamesPlayed = wins + losses;
                        const winRate = gamesPlayed >= i ? (wins / Math.max(gamesPlayed, 1)) * 100 : null;
                        snapshot[name.replace(/\*/g, '').replace(/\./g, '_')] = winRate;
                    }
                });
                winRateHistory.push(snapshot);
            }

            datasets = topPlayers.map((name, index) => {
                const colors = ['#FF1744', '#40C4FF', '#FFD600', '#00E676', '#F50057'];
                const color = colors[index % colors.length];
                const data = winRateHistory.map(h => {
                    const key = name.replace(/\*/g, '').replace(/\./g, '_');
                    return h[key] !== undefined ? h[key] : null;
                });
                return {
                    label: name,
                    spanGaps: true,
                    tension: 0.3,
                    data,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    borderWidth: 3
                };
            });

            labels = winRateHistory.map((h, i) => `${i + 1}ÌöåÏ∞®`);
            yAxisConfig = {
                ticks: { 
                    color: 'var(--text-secondary-color)', 
                    font: { size: 12 },
                    stepSize: 10,
                    callback: (value) => `${value}%`
                },
                grid: { color: 'var(--border-color)', lineWidth: 1 },
                min: 0,
                max: 100,
                title: { display: true, text: 'ÏäπÎ•† (%)', color: 'var(--text-color)', font: { size: 14 } }
            };
        } else {
            if (!history || history.length === 0) {
                console.error("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå:", history);
                showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                return renderMmrChart([], topPlayers, true, matchesData);
            }

            const rounds = matchesData
                .filter(match => match.round && !isNaN(parseInt(match.round)) && parseInt(match.round) <= 6)
                .map(match => parseInt(match.round));
            const maxRound = rounds.length > 0 ? Math.min(6, Math.max(...rounds)) : Math.min(6, history.length);
            console.log(`ÏµúÏã† ÌöåÏ∞®: ${maxRound}, Îß§Ïπò Îç∞Ïù¥ÌÑ∞ ÌöåÏ∞®:`, rounds);
            const displayRounds = Array.from(
                { length: Math.min(maxRound, 6) },
                (_, i) => maxRound - i
            )
                .filter(r => r > 0)
                .reverse();

            datasets = topPlayers.map((name, index) => {
                const colors = ['#FF1744', '#40C4FF', '#FFD600', '#00E676', '#F50057'];
                const color = colors[index % colors.length];
                const data = displayRounds.map(round => {
                    const h = history[round - 1];
                    const key = name.replace(/\*/g, '').replace(/\./g, '_');
                    return h && h[key] !== undefined ? h[key] : null;
                });
                return {
                    label: name,
                    spanGaps: true,
                    tension: 0.3,
                    data,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    borderWidth: 3
                };
            });

            labels = displayRounds.map(round => `${round}ÌöåÏ∞®`);
            yAxisConfig = {
                ticks: { 
                    color: 'var(--text-secondary-color)', 
                    font: { size: 12 },
                    stepSize: 20,
                    callback: (value) => value
                },
                grid: { color: 'var(--border-color)', lineWidth: 1 },
                min: 1450,
                max: 1750,
                title: { display: true, text: 'MMR', color: 'var(--text-color)', font: { size: 14 } }
            };
        }

        if (mmrChart) mmrChart.destroy();

        const lineOptions = {
            scales: {
                x: {
                    ticks: { 
                        color: 'var(--text-secondary-color)', 
                        font: { size: 12 }, 
                        maxRotation: 0, 
                        minRotation: 0,
                        maxTicksLimit: 6
                    },
                    grid: { color: 'var(--border-color)', lineWidth: 1 }
                },
                y: yAxisConfig
            },
            plugins: {
                legend: { 
                    labels: { 
                        color: 'var(--text-color)', 
                        font: { size: 14 },
                        boxWidth: 20,
                        boxHeight: 2,
                        padding: 15
                    },
                    position: 'top'
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    padding: 10,
                    cornerRadius: 6,
                    callbacks: {
                        label: (context) => `${context.dataset.label}: ${context.parsed.y}${useWinRate ? '%' : ''}`
                    }
                }
            },
            interaction: {
                mode: 'nearest',
                intersect: false
            },
            maintainAspectRatio: false,
            responsive: true
        };

        try {
            mmrChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: lineOptions
            });
            console.log(`${useWinRate ? 'ÏäπÎ•†' : 'MMR'} Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏôÑÎ£å!`);
        } catch (error) {
            console.error("Chart.js Î†åÎçîÎßÅ ÏóêÎü¨:", error.message);
            showToast("Í∑∏ÎûòÌîÑ Î†åÎçîÎßÅ Ïã§Ìå®!");
        }
    }

    function showToast(message) {
        console.log(`ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄ: ${message}`);
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 400);
            }, 3000);
        }, 100);
    }

    function applyTheme(theme) {
        console.log(`ÌÖåÎßà Ï†ÅÏö©: ${theme}`);
        document.documentElement.setAttribute('data-theme', theme);
        document.getElementById('theme-toggle').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        localStorage.setItem('theme', theme);
    
        if (radarChart && document.getElementById('player-select')?.value) {
            renderPlayerRadarChart(document.getElementById('player-select').value);
        }
        if (mmrChart && allPlayersData.length > 0) {
            const top5 = allPlayersData.slice(0, 5).map(p => p.name);
            const useWinRate = fullMmrHistory.length === 0;
            renderMmrChart(fullMmrHistory, top5, useWinRate);
        }
    }

    async function loadDashboard() {
        console.log("loadDashboard Ìò∏Ï∂ú");
        if (!db) {
            showToast("DB Ïó∞Í≤∞ Ïã§Ìå®!");
            return;
        }

        try {
            const rankingSnap = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            allPlayersData = rankingSnap.exists() ? rankingSnap.data().players || [] : [];
            console.log("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞:", allPlayersData);
            if (allPlayersData.length === 0) {
                showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            }
        } catch (error) {
            console.error("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®!");
            return;
        }

        allPlayersData = allPlayersData.map(player => {
            let gender = 'M';
            const cleanName = normalizePlayerName(player.name);
            if (femalePlayersList.includes(cleanName) || player.isFemale) {
                gender = 'F';
            }
            console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} (Ï†ïÎ¶¨Îêú Ïù¥Î¶Ñ: ${cleanName}) ÏÑ±Î≥Ñ: ${gender}, dominantWins: ${player.dominantWins || 'ÏóÜÏùå'}`);
            return { ...player, gender };
        });

        const femalePlayers = allPlayersData.filter(p => p.gender === 'F');
        console.log("Ïó¨Ïûê ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù:", femalePlayers.map(p => ({
            name: p.name,
            wins: p.wins,
            losses: p.losses,
            mmr: p.mmr,
            dominantWins: p.dominantWins
        })));

        try {
            const historySnap = await getDoc(doc(db, 'league', 'data', 'mmrHistory', 'v1'));
            if (historySnap.exists()) {
                fullMmrHistory = historySnap.data().snapshots || [];
                console.log("MMR ÌûàÏä§ÌÜ†Î¶¨:", fullMmrHistory);
                if (fullMmrHistory.length === 0) {
                    showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ ÎπÑÏñ¥ ÏûàÏùå! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                }
            } else {
                console.error("mmrHistory/v1 Î¨∏ÏÑú ÏóÜÏùå!");
                showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Î¨∏ÏÑú ÏóÜÏùå! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                fullMmrHistory = [];
            }
        } catch (error) {
            console.error("MMR ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú Ïã§Ìå®! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
            fullMmrHistory = [];
        }

        let matchesData = [];
        try {
            const matchesSnap = await getDocs(collection(db, 'league', 'matches', 'data'));
            matchesData = matchesSnap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
            console.log("Îß§Ïπò Îç∞Ïù¥ÌÑ∞:", matchesData);
            if (matchesData.length === 0) {
                console.warn("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ ÎπÑÏñ¥ ÏûàÏùå!");
                showToast("Îß§Ïπò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§! Ïñ¥ÏõåÎìú Í≥ÑÏÇ∞Ïóê ÏòÅÌñ•ÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.");
            }
        } catch (error) {
            console.error("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message, error.code);
            showToast("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®! Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏßÑÌñâÌï©ÎãàÎã§.");
            matchesData = [];
        }

        let awardsData = {};
        try {
            const awardsSnap = await getDoc(doc(db, 'league', 'data', 'awards', 'v1'));
            awardsData = awardsSnap.exists() ? awardsSnap.data() || {} : {};
            console.log("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞:", awardsData);
        } catch (error) {
            console.error("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®!");
        }

        if (allPlayersData.length > 0) {
            const BASE_GAMES = 15;
            const playedPlayers = allPlayersData.filter(p => totalGames(p) >= 0);
            console.log("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ Ïàò:", playedPlayers.length, "Î™ÖÎã®:", playedPlayers.map(p => p.name));
            if (playedPlayers.length > 0) {
                const getRank = (p, stat) => [...playedPlayers].sort((a, b) => (b[stat] || 0) - (a[stat] || 0)).findIndex(pl => pl.name === p.name) + 1;
                const getPercentileScore = (rank) => playedPlayers.length <= 1 ? 100 : Math.pow((playedPlayers.length - rank) / (playedPlayers.length - 1), 0.7) * 100;

                let mvpMalePlayer = null, maxMvpMaleScore = -Infinity, mvpMaleRunnerUp = null, secondMvpMaleScore = -Infinity;
                let mvpFemalePlayer = null, maxMvpFemaleScore = -Infinity, mvpFemaleRunnerUp = null, secondMvpFemaleScore = -Infinity;
                let mostImprovedPlayer = null, maxImprovedScore = -Infinity, improvedRunnerUp = null, secondImprovedScore = -Infinity;
                let courtKillerPlayer = null, maxCourtKillerScore = -Infinity, courtKillerRunnerUp = null, secondCourtKillerScore = -Infinity;
                let stormerPlayer = null, maxStormerRate = -Infinity, stormerRunnerUp = null, secondStormerRate = -Infinity;
                let impactPlayer = null, maxImpactScore = -Infinity, impactRunnerUp = null, secondImpactScore = -Infinity;
                let diamondHandPlayer = null, maxStabilityScore = -Infinity, diamondHandRunnerUp = null, secondStabilityScore = -Infinity;
                let rivalPair = null, minRivalDiff = Infinity, rivalRunnerUp = null, secondMinRivalDiff = Infinity;
                let formKing = null, maxFormScore = -Infinity, formRunnerUp = null, secondFormScore = -Infinity;

                const rivalries = {};
                matchesData.forEach(match => {
                    if (!match.player1 || !match.player2 || !match.winner) return;
                    const key = [normalizePlayerName(match.player1), normalizePlayerName(match.player2)].sort().join('-');
                    if (!rivalries[key]) {
                        rivalries[key] = { player1: match.player1, player2: match.player2, games: 0, wins1: 0, wins2: 0 };
                    }
                    rivalries[key].games++;
                    if (normalizePlayerName(match.winner) === normalizePlayerName(match.player1)) rivalries[key].wins1++;
                    else if (normalizePlayerName(match.winner) === normalizePlayerName(match.player2)) rivalries[key].wins2++;
                });
                console.log("ÎùºÏù¥Î≤å Îç∞Ïù¥ÌÑ∞:", rivalries);

                matchesData.forEach(match => {
                    if (!match.winnerPlayer1 || !match.winnerPlayer2 || !match.loserPlayer1 || !match.loserPlayer2) return;
                    const winnerTeam = [match.winnerPlayer1, match.winnerPlayer2];
                    const loserTeam = [match.loserPlayer1, match.loserPlayer2];
                    winnerTeam.forEach(winner => {
                        const mmrChange = calculateMMRChange(winner, loserTeam[0], match, allPlayersData);
                        const player = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(winner));
                        if (player) {
                            player.mmr = (parseInt(player.mmr) || 1500) + mmrChange;
                            console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${winner} MMR ÏóÖÎç∞Ïù¥Ìä∏: +${mmrChange} -> ${player.mmr}`);
                        }
                    });
                    loserTeam.forEach(loser => {
                        const mmrChange = calculateMMRChange(winnerTeam[0], loser, match, allPlayersData);
                        const player = allPlayersData.find(p => normalizePlayerName(p.name) === normalizePlayerName(loser));
                        if (player) {
                            player.mmr = Math.max(0, (parseInt(player.mmr) || 1500) - mmrChange);
                            console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${loser} MMR ÏóÖÎç∞Ïù¥Ìä∏: -${mmrChange} -> ${player.mmr}`);
                        }
                    });
                });

                playedPlayers.forEach(player => {
                    const totalGamesPlayed = totalGames(player);
                    const totalSets = parseInt(player.totalSets || totalGamesPlayed);
                    const normFactor = Math.min(1, BASE_GAMES / Math.log(totalGamesPlayed + 1) * Math.log(BASE_GAMES + 1));
                    const normalizedWins = (player.wins || 0) * normFactor;
                    const normalizedGameDiff = (player.gameDiff || 0) * normFactor;
                    let normalizedDominantWins = parseInt(player.dominantWins || 0) * normFactor;
                    const normalizedChampionships = (player.championships || 0) * normFactor;

                    player.mmr = parseInt(player.mmr) || 1500;
                    player.wins = parseInt(player.wins) || 0;
                    player.losses = parseInt(player.losses) || 0;

                    const mmrRank = getRank(player, 'mmr');
                    const mmrScore = getPercentileScore(mmrRank) / 10;
                    player.winRate = totalGamesPlayed > 0 ? normalizedWins / BASE_GAMES : 0;
                    const winRateRank = getRank(player, 'winRate');
                    const winRateScore = getPercentileScore(winRateRank) / 10;
                    player.normChampionships = normalizedChampionships;
                    const champRank = getRank(player, 'normChampionships');
                    const champScore = getPercentileScore(champRank) / 10;
                    player.dominantRate = Math.min(Math.max(parseFloat(player.dominantWins || 0), 0), 100);
                    const dominantRank = getRank(player, 'dominantRate');
                    const dominantScore = getPercentileScore(dominantRank) / 10;
                    player.gameDiffRate = totalGamesPlayed > 0 ? normalizedGameDiff / BASE_GAMES : 0;
                    const gameDiffRank = getRank(player, 'gameDiffRate');
                    const gameDiffScore = getPercentileScore(gameDiffRank) / 10;

                    const mvpScore = ((mmrScore + winRateScore + champScore + dominantScore + gameDiffScore) / 5).toFixed(1);
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} MVP Ï†êÏàò: ${mvpScore}, ÏÑ±Î≥Ñ: ${player.gender}, Îç∞Ïù¥ÌÑ∞:`, {
                        mmrScore, winRateScore, champScore, dominantScore, gameDiffScore,
                        wins: player.wins, losses: player.losses, mmr: player.mmr
                    });
                    if (player.gender === 'M') {
                        if (parseFloat(mvpScore) > maxMvpMaleScore) {
                            secondMvpMaleScore = maxMvpMaleScore;
                            mvpMaleRunnerUp = mvpMalePlayer;
                            maxMvpMaleScore = parseFloat(mvpScore);
                            mvpMalePlayer = { name: player.name, value: mvpScore };
                        } else if (parseFloat(mvpScore) > secondMvpMaleScore && parseFloat(mvpScore) < maxMvpMaleScore) {
                            secondMvpMaleScore = parseFloat(mvpScore);
                            mvpMaleRunnerUp = { name: player.name, value: mvpScore };
                        }
                    } else if (player.gender === 'F') {
                        if (parseFloat(mvpScore) > maxMvpFemaleScore) {
                            secondMvpFemaleScore = maxMvpFemaleScore;
                            mvpFemaleRunnerUp = mvpFemalePlayer;
                            maxMvpFemaleScore = parseFloat(mvpScore);
                            mvpFemalePlayer = { name: player.name, value: mvpScore };
                        } else if (parseFloat(mvpScore) > secondMvpFemaleScore && parseFloat(mvpScore) < maxMvpFemaleScore) {
                            secondMvpFemaleScore = parseFloat(mvpScore);
                            mvpFemaleRunnerUp = { name: player.name, value: mvpScore };
                        }
                    } else {
                        console.warn(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏÑ±Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ïò§Î•ò!`);
                    }

                    const playerHistory = fullMmrHistory.map(h => h[player.name.replace(/\*/g, '').replace(/\./g, '_')]).filter(mmr => mmr !== undefined);
                    const initialMMR = playerHistory.length > 0 ? playerHistory[0] : 1500;
                    player.mmrGrowthRate = initialMMR > 0 ? ((player.mmr - initialMMR) / initialMMR * 100) : 0;
                    const mmrGrowthRank = getRank(player, 'mmrGrowthRate');
                    const mmrGrowthScore = getPercentileScore(mmrGrowthRank) / 10;

                    const earlyGames = playerHistory.slice(0, 3);
                    const lateGames = playerHistory.slice(-3);
                    const earlyWins = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] > earlyGames[i]).length;
                    const lateWins = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] > earlyGames[i]).length;
                    const earlyLosses = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] < earlyGames[i]).length;
                    const lateLosses = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] < earlyGames[i]).length;
                    const earlyWinRate = (earlyWins + earlyLosses) > 0 ? earlyWins / (earlyWins + earlyLosses) : 0;
                    const lateWinRate = (lateWins + lateLosses) > 0 ? lateWins / (lateWins + lateLosses) : 0;
                    player.winRateImprovement = lateWinRate - earlyWinRate;
                    const winRateImproveRank = getRank(player, 'winRateImprovement');
                    const winRateImproveScore = getPercentileScore(winRateImproveRank) / 10;

                    const earlyDominant = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i] >= 6 && earlyGames[i + 1] <= 1).length;
                    const lateDominant = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i] >= 6 && earlyGames[i + 1] <= 1).length;
                    const earlyDominantRate = earlyGames.length > 0 ? earlyDominant / (earlyGames.length / 2) : 0;
                    const lateDominantRate = lateGames.length > 0 ? lateDominant / (lateGames.length / 2) : 0;
                    player.dominantRateImprovement = lateDominantRate - earlyDominantRate;
                    const dominantImproveRank = getRank(player, 'dominantRateImprovement');
                    const dominantImproveScore = getPercentileScore(dominantImproveRank) / 10;

                    const improvedScore = ((mmrGrowthScore * 0.4) + (winRateImproveScore * 0.3) + (dominantImproveScore * 0.3)).toFixed(1);
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Î∞úÏ†ÑÏÉÅ Ï†êÏàò: ${improvedScore}`);
                    if (parseFloat(improvedScore) > maxImprovedScore) {
                        secondImprovedScore = maxImprovedScore;
                        improvedRunnerUp = mostImprovedPlayer;
                        maxImprovedScore = parseFloat(improvedScore);
                        mostImprovedPlayer = { name: player.name, value: improvedScore };
                    } else if (parseFloat(improvedScore) > secondImprovedScore && parseFloat(improvedScore) < maxImprovedScore) {
                        secondImprovedScore = parseFloat(improvedScore);
                        improvedRunnerUp = { name: player.name, value: improvedScore };
                    }

                    const courtKillerRank = getRank(player, 'gameDiffRate');
                    const courtKillerScore = getPercentileScore(courtKillerRank) / 10;
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏΩîÌä∏ ÌÇ¨Îü¨ Ï†êÏàò: ${courtKillerScore}`);
                    if (courtKillerScore > maxCourtKillerScore) {
                        secondCourtKillerScore = maxCourtKillerScore;
                        courtKillerRunnerUp = courtKillerPlayer;
                        maxCourtKillerScore = courtKillerScore;
                        courtKillerPlayer = { name: player.name, value: courtKillerScore.toFixed(1) };
                    } else if (courtKillerScore > secondCourtKillerScore && courtKillerScore < maxCourtKillerScore) {
                        secondCourtKillerScore = courtKillerScore;
                        courtKillerRunnerUp = { name: player.name, value: courtKillerScore.toFixed(1) };
                    }

                    if (totalGamesPlayed >= 0) {
                        const stormerRate = player.mmrGrowthRate;
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÎèåÌíçÏÉÅ ÏÉÅÏäπÎ•†: ${stormerRate.toFixed(1)}%`);
                        if (stormerRate > maxStormerRate) {
                            secondStormerRate = maxStormerRate;
                            stormerRunnerUp = stormerPlayer;
                            maxStormerRate = stormerRate;
                            stormerPlayer = { name: player.name, value: stormerRate.toFixed(1) };
                        } else if (stormerRate > secondStormerRate && stormerRate < maxStormerRate) {
                            secondStormerRate = stormerRate;
                            stormerRunnerUp = { name: player.name, value: stormerRate.toFixed(1) };
                        }
                    }

                    if (player.wins >= 1) {
                        const avgGameDiff = totalSets > 0 ? (player.gameDiff || 0) / totalSets : 0;
                        const seasonMMRIncrease = parseFloat(player.seasonMMRIncrease || 0);
                        const impactScore = (seasonMMRIncrease / Math.max(player.wins, 1)) * (avgGameDiff + 1);
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏûÑÌå©Ìä∏ ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅ - ÏûÑÌå©Ìä∏ Ï†êÏàò: ${impactScore.toFixed(2)}, MMR Ï¶ùÍ∞Ä: ${seasonMMRIncrease}, ÏäπÎ¶¨: ${player.wins}, ÌèâÍ∑† Í≤åÏûÑ ÎìùÏã§: ${avgGameDiff.toFixed(2)}`);
                        if (player.name === "Ï†ïÎûòÎØº" || player.name === "Ï†ïÏõêÎπà" || player.name === "ÍπÄÌÉúÏö©") {
                            console.log(`ÎîîÎ≤ÑÍπÖ [${player.name}] - ÏûÑÌå©Ìä∏ Ï†êÏàò: ${impactScore.toFixed(2)}, MMR Ï¶ùÍ∞Ä: ${seasonMMRIncrease}, ÏäπÎ¶¨: ${player.wins}, ÌèâÍ∑† Í≤åÏûÑ ÎìùÏã§: ${avgGameDiff.toFixed(2)}`);
                        }
                        if (impactScore > maxImpactScore || (impactScore === maxImpactScore && avgGameDiff > (impactPlayer?.avgGameDiff || 0))) {
                            secondImpactScore = maxImpactScore;
                            impactRunnerUp = impactPlayer;
                            maxImpactScore = impactScore;
                            impactPlayer = { name: player.name, value: impactScore.toFixed(2), avgGameDiff };
                        } else if ((impactScore > secondImpactScore || (impactScore === secondImpactScore && avgGameDiff > (impactRunnerUp?.avgGameDiff || 0))) && impactScore < maxImpactScore) {
                            secondImpactScore = impactScore;
                            impactRunnerUp = { name: player.name, value: impactScore.toFixed(2), avgGameDiff };
                        }
                    }

                    if (player.dominantWins >= 1) {
                        const mmrStdDev = playerHistory.length > 1 ? Math.sqrt(playerHistory.map(x => Math.pow(x - playerHistory.reduce((a, b) => a + b, 0) / playerHistory.length, 2)).reduce((a, b) => a + b, 0) / playerHistory.length) : 0;
                        const normalizedStdDev = Math.min(mmrStdDev / 100, 1) * 100;
                        const stabilityScore = parseInt(player.dominantWins || 0) * (100 - normalizedStdDev);
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Îã§Ïù¥ÏïÑÎ™¨Îìú Ìï∏Îìú ÏÉÅ - ÏïàÏ†ïÏÑ± Ï†êÏàò: ${stabilityScore.toFixed(2)}, ÏïïÎèÑ ÏäπÎ¶¨: ${player.dominantWins}, MMR Î≥ÄÎèôÏÑ±: ${normalizedStdDev.toFixed(2)}`);
                        if (player.name === "Ï†ïÎûòÎØº" || player.name === "Ï†ïÏõêÎπà" || player.name === "ÍπÄÌÉúÏö©") {
                            console.log(`ÎîîÎ≤ÑÍπÖ [${player.name}] - ÏïàÏ†ïÏÑ± Ï†êÏàò: ${stabilityScore.toFixed(2)}, ÏïïÎèÑ ÏäπÎ¶¨: ${player.dominantWins}, MMR Î≥ÄÎèôÏÑ±: ${normalizedStdDev.toFixed(2)}`);
                        }
                        if (stabilityScore > maxStabilityScore || (stabilityScore === maxStabilityScore && player.dominantWins > (diamondHandPlayer?.dominantWins || 0))) {
                            secondStabilityScore = maxStabilityScore;
                            diamondHandRunnerUp = diamondHandPlayer;
                            maxStabilityScore = stabilityScore;
                            diamondHandPlayer = { name: player.name, value: stabilityScore.toFixed(2), dominantWins: player.dominantWins };
                        } else if ((stabilityScore > secondStabilityScore || (stabilityScore === secondStabilityScore && player.dominantWins > (diamondHandRunnerUp?.dominantWins || 0))) && stabilityScore < maxStabilityScore) {
                            secondStabilityScore = stabilityScore;
                            diamondHandRunnerUp = { name: player.name, value: stabilityScore.toFixed(2), dominantWins: player.dominantWins };
                        }
                    }

                    if (totalGamesPlayed >= 0) {
                        const avgGameDiff = totalSets > 0 ? (player.gameDiff || 0) / totalSets : 0;
                        const seasonMMRIncrease = parseFloat(player.seasonMMRIncrease || 0);
                        const formScore = (avgGameDiff * 10) + seasonMMRIncrease;
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Ìèº 1ÏúÑ ÏûÑÌå©Ìä∏ ÏßÄÏàò: ${formScore.toFixed(2)}, ÌèâÍ∑† Í≤åÏûÑ ÎìùÏã§: ${avgGameDiff.toFixed(2)}, MMR ÏÉÅÏäπÌè≠: ${seasonMMRIncrease.toFixed(2)}`);
                        if (player.name === "Ï†ïÌòÑÎëê" || player.name === "ÍπÄÎçïÌôò" || player.name === "Ï†ïÎûòÎØº") {
                            console.log(`ÎîîÎ≤ÑÍπÖ [${player.name}] - ÏûÑÌå©Ìä∏ ÏßÄÏàò: ${formScore.toFixed(2)}, ÌèâÍ∑† Í≤åÏûÑ ÎìùÏã§: ${avgGameDiff.toFixed(2)}, MMR ÏÉÅÏäπÌè≠: ${seasonMMRIncrease.toFixed(2)}`);
                        }
                        if (formScore > maxFormScore || (formScore === maxFormScore && avgGameDiff > (formKing?.avgGameDiff || 0))) {
                            secondFormScore = maxFormScore;
                            formRunnerUp = formKing;
                            maxFormScore = formScore;
                            formKing = { name: player.name, value: formScore.toFixed(2), avgGameDiff };
                        } else if ((formScore > secondFormScore || (formScore === secondFormScore && avgGameDiff > (formRunnerUp?.avgGameDiff || 0))) && formScore < maxFormScore) {
                            secondFormScore = formScore;
                            formRunnerUp = { name: player.name, value: formScore.toFixed(2), avgGameDiff };
                        }
                    }
                });

                const rivalDiffs = [];
                for (const key in rivalries) {
                    const rivalry = rivalries[key];
                    if (rivalry.games >= 2) {
                        const diff = Math.abs(rivalry.wins1 - rivalry.wins2);
                        rivalDiffs.push({ key, diff, player1: rivalry.player1, player2: rivalry.player2, games: rivalry.games });
                    }
                }
                rivalDiffs.sort((a, b) => a.diff - b.diff || b.games - a.games);
                if (rivalDiffs.length > 0) {
                    rivalPair = { name: `${rivalDiffs[0].player1} vs ${rivalDiffs[0].player2}`, value: rivalDiffs[0].diff };
                    if (rivalDiffs.length > 1) {
                        rivalRunnerUp = { name: `${rivalDiffs[1].player1} vs ${rivalDiffs[1].player2}`, value: rivalDiffs[1].diff };
                    } else {
                        rivalRunnerUp = { name: '-', value: '-' };
                    }
                } else {
                    rivalPair = { name: '-', value: '-' };
                    rivalRunnerUp = { name: '-', value: '-' };
                }
                console.log("ÎùºÏù¥Î≤å ÏÉÅ Í≤∞Í≥º:", { winner: rivalPair, runnerUp: rivalRunnerUp });

                try {
                    const awardsToSave = {
                        mvpMale: { winner: mvpMalePlayer || { name: '-', value: '-' }, runnerUp: mvpMaleRunnerUp || { name: '-', value: '-' } },
                        mvpFemale: { winner: mvpFemalePlayer || { name: '-', value: '-' }, runnerUp: mvpFemaleRunnerUp || { name: '-', value: '-' } },
                        mostImproved: { winner: mostImprovedPlayer || { name: '-', value: '-' }, runnerUp: improvedRunnerUp || { name: '-', value: '-' } },
                        courtKiller: { winner: courtKillerPlayer || { name: '-', value: '-' }, runnerUp: courtKillerRunnerUp || { name: '-', value: '-' } },
                        stormer: { winner: stormerPlayer || { name: '-', value: '-' }, runnerUp: stormerRunnerUp || { name: '-', value: '-' } },
                        impactPlayer: { winner: impactPlayer || { name: '-', value: '-' }, runnerUp: impactRunnerUp || { name: '-', value: '-' } },
                        diamondHand: { winner: diamondHandPlayer || { name: '-', value: '-' }, runnerUp: diamondHandRunnerUp || { name: '-', value: '-' } },
                        rivalPair: { winner: rivalPair || { name: '-', value: '-' }, runnerUp: rivalRunnerUp || { name: '-', value: '-' } },
                        formKing: { winner: formKing || { name: '-', value: '-' }, runnerUp: formRunnerUp || { name: '-', value: '-' } }
                    };
                    console.log("Ï†ÄÏû•Ìï† Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞:", awardsToSave);
                    await setDoc(doc(db, 'league', 'data', 'awards', 'v1'), awardsToSave, { merge: true });
                    console.log("Ïñ¥ÏõåÎìú Ï†ÄÏû• ÏôÑÎ£å!");
                } catch (error) {
                    console.error("Ïñ¥ÏõåÎìú Ï†ÄÏû• Ïã§Ìå®:", error.message);
                    showToast("Ïñ¥ÏõåÎìú Ï†ÄÏû• Ïã§Ìå®! Ïû¨ÏãúÎèÑ Ï§ë...");
                    setTimeout(async () => {
                        try {
                            await setDoc(doc(db, 'league', 'data', 'awards', 'v1'), {
                                mvpMale: { winner: mvpMalePlayer || { name: '-', value: '-' }, runnerUp: mvpMaleRunnerUp || { name: '-', value: '-' } },
                                mvpFemale: { winner: mvpFemalePlayer || { name: '-', value: '-' }, runnerUp: mvpFemaleRunnerUp || { name: '-', value: '-' } },
                                mostImproved: { winner: mostImprovedPlayer || { name: '-', value: '-' }, runnerUp: improvedRunnerUp || { name: '-', value: '-' } },
                                courtKiller: { winner: courtKillerPlayer || { name: '-', value: '-' }, runnerUp: courtKillerRunnerUp || { name: '-', value: '-' } },
                                stormer: { winner: stormerPlayer || { name: '-', value: '-' }, runnerUp: stormerRunnerUp || { name: '-', value: '-' } },
                                impactPlayer: { winner: impactPlayer || { name: '-', value: '-' }, runnerUp: impactRunnerUp || { name: '-', value: '-' } },
                                diamondHand: { winner: diamondHandPlayer || { name: '-', value: '-' }, runnerUp: diamondHandRunnerUp || { name: '-', value: '-' } },
                                rivalPair: { winner: rivalPair || { name: '-', value: '-' }, runnerUp: rivalRunnerUp || { name: '-', value: '-' } },
                                formKing: { winner: formKing || { name: '-', value: '-' }, runnerUp: formRunnerUp || { name: '-', value: '-' } }
                            }, { merge: true });
                            console.log("Ïñ¥ÏõåÎìú Ïû¨ÏãúÎèÑ Ï†ÄÏû• ÏôÑÎ£å!");
                        } catch (retryError) {
                            console.error("Ïñ¥ÏõåÎìú Ïû¨ÏãúÎèÑ Ïã§Ìå®:", retryError.message);
                            showToast("Ïñ¥ÏõåÎìú Ï†ÄÏû• ÏµúÏ¢Ö Ïã§Ìå®!");
                        }
                    }, 1000);
                }
            } else {
                console.warn("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ ÏóÜÏùå!");
                showToast("Ïñ¥ÏõåÎìú Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            }
        } else {
            console.warn("ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        const top5PlayerNames = allPlayersData.slice(0, 5).map(p => p.name);
        console.log("TOP 5 ÌîåÎ†àÏù¥Ïñ¥:", top5PlayerNames);

        if (top5PlayerNames.length > 0) {
            const useWinRate = fullMmrHistory.length === 0;
            renderMmrChart(fullMmrHistory, top5PlayerNames, useWinRate, matchesData);
        } else {
            showToast("TOP 5 ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        if (allPlayersData.length > 0) {
            setupPlayerSelector();
            renderPlayerRadarChart(allPlayersData[0].name);
        } else {
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        const awardDetails = {
            mvpMale: { title: "ÏãúÏ¶å MVP (ÎÇ®)", icon: "üëë" },
            mvpFemale: { title: "ÏãúÏ¶å MVP (Ïó¨)", icon: "üëë" },
            mostImproved: { title: "ÏãúÏ¶å Î∞úÏ†ÑÏÉÅ", icon: "üöÄ" },
            courtKiller: { title: "ÏãúÏ¶å ÏΩîÌä∏ÌÇ¨Îü¨", icon: "üí£" },
            stormer: { title: "ÏãúÏ¶å ÎèåÌíçÏÉÅ", icon: "üå™Ô∏è" },
            impactPlayer: { title: "ÏãúÏ¶å ÏûÑÌå©Ìä∏ ÌîåÎ†àÏù¥Ïñ¥", icon: "‚ö°" },
            diamondHand: { title: "ÏãúÏ¶å Îã§Ïù¥ÏïÑÎ™¨Îìú Ìï∏Îìú", icon: "üíé" },
            rivalPair: { title: "ÏãúÏ¶å ÎùºÏù¥Î≤å", icon: "‚öîÔ∏è" },
            formKing: { title: "ÏãúÏ¶å Ìèº 1ÏúÑ", icon: "üî•" }
        };

        const grid = document.querySelector('.awards-grid');
        if (!grid) {
            console.error("awards-grid ÏöîÏÜå ÏóÜÏùå!");
            showToast("Ïñ¥ÏõåÎìú Í∑∏Î¶¨Îìú Ïò§Î•ò!");
            return;
        }
        grid.innerHTML = '';

        for (const key in awardDetails) {
            const awardInfo = awardDetails[key];
            const data = awardsData[key] || { winner: { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } };
            const winner = data.winner?.name || data.name || '-';
            const winnerValue = data.winner?.value || data.value || '-';
            const runnerUp = data.runnerUp?.name || '-';
            const runnerUpValue = data.runnerUp?.value || '-';

            console.log(`Ïñ¥ÏõåÎìú Î†åÎçîÎßÅ - ${awardInfo.title}: winner=${winner}, value=${winnerValue}, runnerUp=${runnerUp}, runnerUpValue=${runnerUpValue}`);

            const card = document.createElement('div');
            card.className = 'award-card';
            card.innerHTML = `
                <div class="award-icon">${awardInfo.icon}</div>
                <div class="award-title">${awardInfo.title}</div>
                <div class="award-winner">${winner}</div>
                <div class="award-value">${key === 'impactPlayer' ? 'ÏûÑÌå©Ìä∏ Ï†êÏàò' : key === 'diamondHand' ? 'ÏïàÏ†ïÏÑ± Ï†êÏàò' : key === 'rivalPair' ? 'Ï†êÏàòÏ∞®Ïù¥' : key === 'formKing' ? 'ÏûÑÌå©Ìä∏ ÏßÄÏàò' : 'Ï†êÏàò'}: ${winnerValue}${key === 'impactPlayer' || key === 'diamondHand' ? '' : ''}</div>
                <div class="award-runner-up">2ÏúÑ: ${runnerUp} (${key === 'impactPlayer' ? 'ÏûÑÌå©Ìä∏ Ï†êÏàò' : key === 'diamondHand' ? 'ÏïàÏ†ïÏÑ± Ï†êÏàò' : key === 'rivalPair' ? 'Ï†êÏàòÏ∞®Ïù¥' : key === 'formKing' ? 'ÏûÑÌå©Ìä∏ ÏßÄÏàò' : 'Ï†êÏàò'}: ${runnerUpValue}${key === 'impactPlayer' || key === 'diamondHand' ? '' : ''})</div>
            `;
            grid.appendChild(card);
        }
        console.log("Ïñ¥ÏõåÎìú Í∑∏Î¶¨Îìú Î†åÎçîÎßÅ ÏôÑÎ£å!");
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded Ïù¥Î≤§Ìä∏ Î∞úÏÉù");
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        } else {
            console.warn("theme-toggle ÏöîÏÜå ÏóÜÏùå!");
        }
        
        loadDashboard();

        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
            });
        }
    });
</script>
</body>
</html>