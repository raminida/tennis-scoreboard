<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 ÎûòÎûëÍ∞ÄÎ°úÏä§ ÎåÄÏãúÎ≥¥Îìú</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; }
        .container { max-width: 960px; margin: auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding: 20px 0; margin-bottom: 3rem; letter-spacing: -2px; }
        .section { background: var(--surface-color); padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 3rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 2.2rem; color: var(--primary-color); margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        .charts-container { display: grid; grid-template-columns: 1fr; gap: 40px; margin-bottom: 40px; }
        .chart-control { margin-bottom: 20px; text-align: center; }
        .chart-control label { font-weight: bold; margin-right: 10px; }
        .chart-control select { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); background-color: var(--surface-color); color: var(--text-color); }
        .awards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; }
        .award-card { background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; text-align: center; }
        html[data-theme="light"] .award-card { background: #F9FAFB; }
        .award-icon { font-size: 3rem; margin-bottom: 10px; color: var(--accent-gold); }
        .award-title { font-family: 'Poppins', sans-serif; font-size: 1.3rem; color: var(--primary-variant-color); margin-bottom: 5px; }
        .award-winner { font-size: 1.1rem; font-weight: 700; color: var(--text-color); }
        .award-value { font-size: 0.9rem; color: var(--text-secondary-color); }
        .award-runner-up { font-size: 0.9rem; color: var(--text-secondary-color); margin-top: 5px; font-weight: 500; }
        .btn { display: inline-block; padding: 12px 28px; margin: 10px 5px; background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: 8px; font-weight: 700; border: none; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .theme-toggle { position: fixed; top: 20px; right: 20px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #333, #111);
            color: #fff;
            padding: 12px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 15px var(--shadow-color);
            opacity: 0;
            transition: opacity 0.4s, transform 0.4s;
            font-weight: 700;
            z-index: 1000;
        }
        html[data-theme="light"] .toast {
            background: linear-gradient(135deg, #f9f9f9, #f1f1f1);
            color: #333;
        }
        .toast.show {
            opacity: 1;
        }
        @media (max-width: 640px) { 
            body { padding: 15px; } 
            h1 { font-size: 2.2rem; } 
            h2 { font-size: 1.8rem; } 
            .section { padding: 20px; } 
            .awards-grid { grid-template-columns: 1fr; } 
        }
        #mmr-chart-container canvas {
            max-height: 600px;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">‚òÄÔ∏è</button>
    <div class="container">
        <h1>2025 ÎûòÎûëÍ∞ÄÎ°úÏä§ ÎåÄÏãúÎ≥¥Îìú</h1>
        <div class="section">
            <h2>ÌÜµÍ≥Ñ Ï∞®Ìä∏</h2>
            <div class="charts-container">
                <div id="mmr-chart-container">
                    <h3>TOP 5 MMR Ï∂îÏù¥</h3>
                    <canvas id="mmr-chart"></canvas>
                </div>
                <div>
                    <h3>ÏÑ†Ïàò Îä•Î†•Ïπò Î†àÏù¥Îçî</h3>
                    <div class="chart-control">
                        <label for="player-select">ÏÑ†Ïàò ÏÑ†ÌÉù:</label>
                        <select id="player-select"></select>
                    </div>
                    <canvas id="player-radar-chart"></canvas>
                </div>
            </div>
        </div>
        <div class="section">
            <h2>üèÜ ÏãúÏ¶å Ïñ¥ÏõåÎìú</h2>
            <div class="awards-grid"></div>
            <div style="text-align: center; margin-top: 30px;"><a href="index.html" class="btn">Î©îÏù∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</a></div>
        </div>
    </div>
<script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    const firebaseConfig = { 
        apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU", 
        authDomain: "tennis-plan-jibung.firebaseapp.com", 
        projectId: "tennis-plan-jibung", 
        storageBucket: "tennis-plan-jibung.appspot.com", 
        messagingSenderId: "491083537160", 
        appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd" 
    };
    let db;
    try { 
        db = getFirestore(initializeApp(firebaseConfig)); 
    } catch (e) { 
        console.error("Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®:", e);
        showToast("Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®!");
    }

    let mmrChart, radarChart;
    let allPlayersData = [];
    let fullMmrHistory = [];

    function totalGames(player) {
        return (parseInt(player.wins || 0) + parseInt(player.losses || 0)) || 1;
    }

    function setupPlayerSelector() {
        console.log("setupPlayerSelector Ìò∏Ï∂ú");
        const select = document.getElementById('player-select');
        if (!select) {
            console.error("player-select ÏöîÏÜå ÏóÜÏùå!");
            showToast("ÏÑ†Ïàò ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥ Ïò§Î•ò!");
            return;
        }
        select.innerHTML = '';
        allPlayersData.forEach(player => {
            const option = document.createElement('option');
            option.value = player.name;
            option.textContent = player.name;
            select.appendChild(option);
        });
        select.addEventListener('change', (e) => {
            console.log(`ÏÑ†Ïàò ÏÑ†ÌÉù: ${e.target.value}`);
            renderPlayerRadarChart(e.target.value);
        });
        console.log("ÏÑ†Ïàò ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥ ÏÑ§Ï†ï ÏôÑÎ£å!");
    }

    function renderPlayerRadarChart(playerName) {
        console.log(`renderPlayerRadarChart Ìò∏Ï∂ú: ${playerName}`);
        const player = allPlayersData.find(p => p.name === playerName);
        if (!player) {
            console.error(`ÌîåÎ†àÏù¥Ïñ¥ ${playerName} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!`);
            showToast(`ÌîåÎ†àÏù¥Ïñ¥ ${playerName} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!`);
            return;
        }

        const ctx = document.getElementById('player-radar-chart')?.getContext('2d');
        if (!ctx) {
            console.error("player-radar-chart Ï∫îÎ≤ÑÏä§ ÏóÜÏùå!");
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Ï∫îÎ≤ÑÏä§ Ïò§Î•ò!");
            return;
        }

        const playedPlayers = allPlayersData.filter(p => totalGames(p) > 0);
        if (playedPlayers.length === 0) {
            console.error("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            return;
        }

        const getRank = (p, stat) => [...playedPlayers].sort((a,b) => (b[stat] || 0) - (a[stat] || 0)).findIndex(pl => pl.name === p.name) + 1;
        const getPercentileScore = (rank) => playedPlayers.length <= 1 ? 100 : Math.pow((playedPlayers.length - rank) / (playedPlayers.length - 1), 0.7) * 100;

        const mmrRank = getRank(player, 'mmr');
        const mmrScore = getPercentileScore(mmrRank);

        allPlayersData.forEach(p => p.winRate = totalGames(p) > 0 ? p.wins / totalGames(p) : 0);
        const winRateRank = getRank(player, 'winRate');
        const winRateScore = getPercentileScore(winRateRank);

        const totalGamesPlayed = totalGames(player);
        allPlayersData.forEach(p => p.avgGameDiff = totalGames(p) > 0 ? (p.gameDiff || 0) / totalGames(p) : 0);
        const avgGameDiffRank = getRank(player, 'avgGameDiff');
        const avgGameDiffScore = getPercentileScore(avgGameDiffRank);

        allPlayersData.forEach(p => p.dominantRate = totalGames(p) > 0 ? (p.dominantWins || 0) / totalGames(p) : 0);
        const dominantRank = getRank(player, 'dominantRate');
        const dominantScore = getPercentileScore(dominantRank);

        const playerMmrHistory = fullMmrHistory.map(h => h[playerName.replace(/\*/g, '').replace(/\./g, '_')]).filter(mmr => mmr !== undefined);
        let consistencyScore = 0;
        if (playerMmrHistory.length < 2 || playerMmrHistory.every((v, i, a) => !i || v >= a[i-1])) {
            consistencyScore = 100;
        } else {
            const mean = playerMmrHistory.reduce((a, b) => a + b, 0) / playerMmrHistory.length;
            const stddev = Math.sqrt(playerMmrHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / playerMmrHistory.length);
            consistencyScore = Math.max(0, 100 - (stddev * 2));
        }

        allPlayersData.forEach(p => p.avgPointsPerGame = totalGames(p) > 0 ? (p.totalPoints || 0) / totalGames(p) : 0);
        const pointsRank = getRank(player, 'avgPointsPerGame');
        const pointsScore = getPercentileScore(pointsRank);

        const data = {
            labels: ['MMR', 'ÏäπÎ•†', 'ÌèâÍ∑† Í≤åÏûÑÎìùÏã§', 'ÏïïÎèÑÎ†•', 'Íæ∏Ï§ÄÌï®', 'ÌèâÍ∑† Ìè¨Ïù∏Ìä∏'],
            datasets: [{
                label: player.name,
                data: [ mmrScore, winRateScore, avgGameDiffScore, dominantScore, consistencyScore, pointsScore ],
                backgroundColor: 'rgba(76, 175, 80, 0.2)',
                borderColor: 'rgba(76, 175, 80, 1)',
                pointBackgroundColor: 'rgba(76, 175, 80, 1)',
            }]
        };

        if (radarChart) radarChart.destroy();

        const radarOptions = {
            elements: { line: { borderWidth: 3 } },
            scales: {
                r: {
                    angleLines: { color: 'var(--border-color)' },
                    grid: { color: 'var(--border-color)' },
                    pointLabels: { font: { size: 14 }, color: 'var(--text-color)' },
                    ticks: {
                        display: true,
                        stepSize: 20,
                        backdropColor: 'transparent',
                        color: 'var(--text-secondary-color)'
                    },
                    min: 0,
                    max: 100
                }
            },
            plugins: { legend: { labels: { color: 'var(--text-color)', font: { size: 16 } } } }
        };

        try {
            radarChart = new Chart(ctx, { type: 'radar', data: data, options: radarOptions });
            console.log(`Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏôÑÎ£å: ${playerName}`);
        } catch (error) {
            console.error("Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏóêÎü¨:", error.message);
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Î†åÎçîÎßÅ Ïã§Ìå®!");
        }
    }

    function renderMmrChart(history, topPlayers, useWinRate = false) {
        console.log("renderMmrChart Ìò∏Ï∂ú");
        const ctx = document.getElementById('mmr-chart')?.getContext('2d');
        if (!ctx) {
            console.error("mmr-chart Ï∫îÎ≤ÑÏä§ ÏóÜÏùå!");
            showToast("Í∑∏ÎûòÌîÑ Ï∫îÎ≤ÑÏä§ Ïò§Î•ò!");
            return;
        }

        if (!topPlayers || topPlayers.length === 0) {
            console.error("TOP ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå:", topPlayers);
            showToast("TOP ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            return;
        }

        const chartContainer = document.getElementById('mmr-chart-container');
        const titleElement = chartContainer?.querySelector('h3');
        if (titleElement) {
            titleElement.textContent = useWinRate ? "TOP 5 ÏäπÎ•† Ï∂îÏù¥" : "TOP 5 MMR Ï∂îÏù¥";
        } else {
            console.warn("MMR Í∑∏ÎûòÌîÑ Ï†úÎ™©(h3) ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå!");
            showToast("MMR Í∑∏ÎûòÌîÑ Ï†úÎ™© Ïò§Î•ò!");
        }

        let datasets, labels, yAxisConfig;
        if (useWinRate) {
            const winRateHistory = [];
            let maxGames = 0;
            topPlayers.forEach(name => {
                const player = allPlayersData.find(p => p.name === name);
                if (player) {
                    const totalGamesPlayed = totalGames(player);
                    maxGames = Math.max(maxGames, totalGamesPlayed);
                }
            });

            for (let i = 1; i <= Math.min(maxGames, 6); i++) {
                const snapshot = { round: i };
                topPlayers.forEach(name => {
                    const player = allPlayersData.find(p => p.name === name);
                    if (player) {
                        const wins = parseInt(player.wins || 0);
                        const losses = parseInt(player.losses || 0);
                        const gamesPlayed = wins + losses;
                        const winRate = gamesPlayed >= i ? (wins / Math.max(gamesPlayed, 1)) * 100 : null;
                        snapshot[name.replace(/\*/g, '').replace(/\./g, '_')] = winRate;
                    }
                });
                winRateHistory.push(snapshot);
            }

            datasets = topPlayers.map((name, index) => {
                const colors = ['#FF1744', '#40C4FF', '#FFD600', '#00E676', '#F50057'];
                const color = colors[index % colors.length];
                const data = winRateHistory.map(h => {
                    const key = name.replace(/\*/g, '').replace(/\./g, '_');
                    return h[key] !== undefined ? h[key] : null;
                });
                return {
                    label: name,
                    spanGaps: true,
                    tension: 0.3,
                    data,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    borderWidth: 3
                };
            });

            labels = winRateHistory.map((h, i) => `${i + 1}ÌöåÏ∞®`);
            yAxisConfig = {
                ticks: { 
                    color: 'var(--text-secondary-color)', 
                    font: { size: 12 },
                    stepSize: 10,
                    callback: (value) => `${value}%`
                },
                grid: { color: 'var(--border-color)', lineWidth: 1 },
                min: 0,
                max: 100,
                title: { display: true, text: 'ÏäπÎ•† (%)', color: 'var(--text-color)', font: { size: 14 } }
            };
        } else {
            if (!history || history.length === 0) {
                console.error("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå:", history);
                showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                return renderMmrChart([], topPlayers, true);
            }

            // ÏµúÏã† ÌöåÏ∞® Í∏∞Ï§ÄÏúºÎ°ú ÏµúÎåÄ 6ÌöåÏ∞® Ïó≠Ïàú
            const maxRound = Math.min(history.length, 6);
            const rounds = Array.from({ length: maxRound }, (_, i) => maxRound - i).reverse(); // [1,2,3,4,5,6]
            datasets = topPlayers.map((name, index) => {
                const colors = ['#FF1744', '#40C4FF', '#FFD600', '#00E676', '#F50057'];
                const color = colors[index % colors.length];
                const data = rounds.map(round => {
                    const h = history[round - 1];
                    const key = name.replace(/\*/g, '').replace(/\./g, '_');
                    return h && h[key] !== undefined ? h[key] : null;
                });
                return {
                    label: name,
                    spanGaps: true,
                    tension: 0.3,
                    data,
                    borderColor: color,
                    backgroundColor: `${color}33`,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    borderWidth: 3
                };
            });

            labels = rounds.map(round => `${round}ÌöåÏ∞®`);
            yAxisConfig = {
                ticks: { 
                    color: 'var(--text-secondary-color)', 
                    font: { size: 12 },
                    stepSize: 20,
                    callback: (value) => value
                },
                grid: { color: 'var(--border-color)', lineWidth: 1 },
                min: 1450,
                max: 1750,
                title: { display: true, text: 'MMR', color: 'var(--text-color)', font: { size: 14 } }
            };
        }

        if (mmrChart) mmrChart.destroy();

        const lineOptions = {
            scales: {
                x: {
                    ticks: { 
                        color: 'var(--text-secondary-color)', 
                        font: { size: 12 }, 
                        maxRotation: 0, 
                        minRotation: 0,
                        maxTicksLimit: 6
                    },
                    grid: { color: 'var(--border-color)', lineWidth: 1 }
                },
                y: yAxisConfig
            },
            plugins: {
                legend: { 
                    labels: { 
                        color: 'var(--text-color)', 
                        font: { size: 14 },
                        boxWidth: 20,
                        boxHeight: 2,
                        padding: 15
                    },
                    position: 'top'
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    padding: 10,
                    cornerRadius: 6,
                    callbacks: {
                        label: (context) => `${context.dataset.label}: ${context.parsed.y}${useWinRate ? '%' : ''}`
                    }
                }
            },
            interaction: {
                mode: 'nearest',
                intersect: false
            },
            maintainAspectRatio: false,
            responsive: true
        };

        try {
            mmrChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: lineOptions
            });
            console.log(`${useWinRate ? 'ÏäπÎ•†' : 'MMR'} Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏôÑÎ£å!`);
        } catch (error) {
            console.error("Chart.js Î†åÎçîÎßÅ ÏóêÎü¨:", error.message);
            showToast("Í∑∏ÎûòÌîÑ Î†åÎçîÎßÅ Ïã§Ìå®!");
        }
    }

    function showToast(message) {
        console.log(`ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄ: ${message}`);
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 400);
            }, 3000);
        }, 100);
    }

    function applyTheme(theme) {
        console.log(`ÌÖåÎßà Ï†ÅÏö©: ${theme}`);
        document.documentElement.setAttribute('data-theme', theme);
        document.getElementById('theme-toggle').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        localStorage.setItem('theme', theme);
    
        if (radarChart && document.getElementById('player-select')?.value) {
            renderPlayerRadarChart(document.getElementById('player-select').value);
        }
        if (mmrChart && allPlayersData.length > 0) {
            const top5 = allPlayersData.slice(0, 5).map(p => p.name);
            const useWinRate = fullMmrHistory.length === 0;
            renderMmrChart(fullMmrHistory, top5, useWinRate);
        }
    }

    async function loadDashboard() {
        console.log("loadDashboard Ìò∏Ï∂ú");
        if (!db) {
            showToast("DB Ïó∞Í≤∞ Ïã§Ìå®!");
            return;
        }

        try {
            const rankingSnap = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            allPlayersData = rankingSnap.exists() ? rankingSnap.data().players || [] : [];
            console.log("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞:", allPlayersData);
            if (allPlayersData.length === 0) {
                showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            }
        } catch (error) {
            console.error("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®!");
            return;
        }

        // ÏÑ±Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
        allPlayersData = allPlayersData.map(player => {
            const gender = player.name.endsWith('*') ? 'F' : 'M';
            console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏÑ±Î≥Ñ: ${gender}`);
            return { ...player, gender };
        });

        try {
            const historySnap = await getDoc(doc(db, 'league', 'data', 'mmrHistory', 'v1'));
            if (historySnap.exists()) {
                fullMmrHistory = historySnap.data().snapshots || [];
                console.log("MMR ÌûàÏä§ÌÜ†Î¶¨:", fullMmrHistory);
                if (fullMmrHistory.length === 0) {
                    showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ ÎπÑÏñ¥ ÏûàÏùå! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                }
            } else {
                console.error("mmrHistory/v1 Î¨∏ÏÑú ÏóÜÏùå!");
                showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Î¨∏ÏÑú ÏóÜÏùå! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
                fullMmrHistory = [];
            }
        } catch (error) {
            console.error("MMR ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("MMR ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú Ïã§Ìå®! ÏäπÎ•† Í∑∏ÎûòÌîÑÎ°ú Ï†ÑÌôò.");
            fullMmrHistory = [];
        }

        let matchesData = [];
        try {
            const matchesSnap = await getDocs(collection(db, 'league', 'matches', 'data'));
            matchesData = matchesSnap.docs.map(doc => doc.data());
            console.log("Îß§Ïπò Îç∞Ïù¥ÌÑ∞:", matchesData);
            if (matchesData.length === 0) {
                console.warn("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ ÎπÑÏñ¥ ÏûàÏùå!");
                showToast("Îß§Ïπò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§! Ïñ¥ÏõåÎìú Í≥ÑÏÇ∞Ïóê ÏòÅÌñ•ÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.");
            }
        } catch (error) {
            console.error("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message, error.code);
            showToast("Îß§Ïπò Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®! Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏßÑÌñâÌï©ÎãàÎã§.");
            matchesData = [];
        }

        let awardsData = {};
        try {
            const awardsSnap = await getDoc(doc(db, 'league', 'data', 'awards', 'v1'));
            awardsData = awardsSnap.exists() ? awardsSnap.data() || {} : {};
            console.log("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞:", awardsData);
        } catch (error) {
            console.error("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë ÏóêÎü¨:", error.message);
            showToast("Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®!");
        }

        if (allPlayersData.length > 0) {
            const BASE_GAMES = 15;
            const playedPlayers = allPlayersData.filter(p => totalGames(p) >= 3);
            console.log("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ Ïàò:", playedPlayers.length);
            if (playedPlayers.length > 0) {
                const getRank = (p, stat) => [...playedPlayers].sort((a, b) => (b[stat] || 0) - (a[stat] || 0)).findIndex(pl => pl.name === p.name) + 1;
                const getPercentileScore = (rank) => playedPlayers.length <= 1 ? 100 : Math.pow((playedPlayers.length - rank) / (playedPlayers.length - 1), 0.7) * 100;

                let mvpMalePlayer = null, maxMvpMaleScore = -Infinity, mvpMaleRunnerUp = null, secondMvpMaleScore = -Infinity;
                let mvpFemalePlayer = null, maxMvpFemaleScore = -Infinity, mvpFemaleRunnerUp = null, secondMvpFemaleScore = -Infinity;
                let mostImprovedPlayer = null, maxImprovedScore = -Infinity, improvedRunnerUp = null, secondImprovedScore = -Infinity;
                let courtKillerPlayer = null, maxCourtKillerScore = -Infinity, courtKillerRunnerUp = null, secondCourtKillerScore = -Infinity;
                let stormerPlayer = null, maxStormerRate = -Infinity, stormerRunnerUp = null, secondStormerRate = -Infinity;
                let dominatorPlayer = null, maxDominatorRate = -Infinity, dominatorRunnerUp = null, secondDominatorRate = -Infinity;
                let epicBattlePlayer = null, maxCloseMatchRate = -Infinity, epicBattleRunnerUp = null, secondCloseMatchRate = -Infinity;
                let rivalPair = null, minRivalDiff = Infinity;
                let formKing = null, maxFormScore = -Infinity;

                const rivalries = {};
                matchesData.forEach(match => {
                    const key = [match.player1, match.player2].sort().join('-');
                    if (!rivalries[key]) {
                        rivalries[key] = { player1: match.player1, player2: match.player2, games: 0, wins1: 0, wins2: 0 };
                    }
                    rivalries[key].games++;
                    if (match.winner === match.player1) rivalries[key].wins1++;
                    else if (match.winner === match.player2) rivalries[key].wins2++;
                });
                console.log("ÎùºÏù¥Î≤å Îç∞Ïù¥ÌÑ∞:", rivalries);

                const closeMatches = {};
                matchesData.forEach(match => {
                    if (match.gameDiff !== undefined && Math.abs(match.gameDiff) <= 2 && match.player1 && match.player2) {
                        [match.player1, match.player2].forEach(player => {
                            if (!closeMatches[player]) closeMatches[player] = 0;
                            closeMatches[player]++;
                        });
                    }
                });
                console.log("Ï†ëÏ†Ñ Í≤ΩÍ∏∞ Ïàò:", closeMatches);

                playedPlayers.forEach(player => {
                    const totalGamesPlayed = totalGames(player);
                    const normFactor = Math.min(1, BASE_GAMES / Math.log(totalGamesPlayed + 1) * Math.log(BASE_GAMES + 1));
                    const normalizedWins = (player.wins || 0) * normFactor;
                    const normalizedGameDiff = (player.gameDiff || 0) * normFactor;
                    const normalizedDominantWins = (player.dominantWins || 0) * normFactor;
                    const normalizedChampionships = (player.championships || 0) * normFactor;

                    const mmrRank = getRank(player, 'mmr');
                    const mmrScore = getPercentileScore(mmrRank) / 10;
                    player.winRate = totalGamesPlayed > 0 ? normalizedWins / BASE_GAMES : 0;
                    const winRateRank = getRank(player, 'winRate');
                    const winRateScore = getPercentileScore(winRateRank) / 10;
                    player.normChampionships = normalizedChampionships;
                    const champRank = getRank(player, 'normChampionships');
                    const champScore = getPercentileScore(champRank) / 10;
                    player.dominantRate = BASE_GAMES > 0 ? normalizedDominantWins / BASE_GAMES : 0;
                    const dominantRank = getRank(player, 'dominantRate');
                    const dominantScore = getPercentileScore(dominantRank) / 10;
                    player.gameDiffRate = totalGamesPlayed > 0 ? normalizedGameDiff / BASE_GAMES : 0;
                    const gameDiffRank = getRank(player, 'gameDiffRate');
                    const gameDiffScore = getPercentileScore(gameDiffRank) / 10;

                    // MVP Í≥ÑÏÇ∞ (ÎÇ®/Ïó¨ Î∂ÑÎ¶¨)
                    const mvpScore = ((mmrScore + winRateScore + champScore + dominantScore + gameDiffScore) / 5).toFixed(1);
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} MVP Ï†êÏàò: ${mvpScore}, ÏÑ±Î≥Ñ: ${player.gender}`);
                    if (player.gender === 'M') {
                        if (parseFloat(mvpScore) > maxMvpMaleScore) {
                            secondMvpMaleScore = maxMvpMaleScore;
                            mvpMaleRunnerUp = mvpMalePlayer;
                            maxMvpMaleScore = parseFloat(mvpScore);
                            mvpMalePlayer = { name: player.name, value: mvpScore };
                        } else if (parseFloat(mvpScore) > secondMvpMaleScore && parseFloat(mvpScore) < maxMvpMaleScore) {
                            secondMvpMaleScore = parseFloat(mvpScore);
                            mvpMaleRunnerUp = { name: player.name, value: mvpScore };
                        }
                    } else if (player.gender === 'F') {
                        if (parseFloat(mvpScore) > maxMvpFemaleScore) {
                            secondMvpFemaleScore = maxMvpFemaleScore;
                            mvpFemaleRunnerUp = mvpFemalePlayer;
                            maxMvpFemaleScore = parseFloat(mvpScore);
                            mvpFemalePlayer = { name: player.name, value: mvpScore };
                        } else if (parseFloat(mvpScore) > secondMvpFemaleScore && parseFloat(mvpScore) < maxMvpFemaleScore) {
                            secondMvpFemaleScore = parseFloat(mvpScore);
                            mvpFemaleRunnerUp = { name: player.name, value: mvpScore };
                        }
                    } else {
                        console.warn(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏÑ±Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ïò§Î•ò!`);
                    }

                    const playerHistory = fullMmrHistory.map(h => h[player.name.replace(/\*/g, '').replace(/\./g, '_')]).filter(mmr => mmr !== undefined);
                    const initialMMR = playerHistory.length > 0 ? playerHistory[0] : 1500;
                    player.mmrGrowthRate = initialMMR > 0 ? ((player.mmr - initialMMR) / initialMMR * 100) : 0;
                    const mmrGrowthRank = getRank(player, 'mmrGrowthRate');
                    const mmrGrowthScore = getPercentileScore(mmrGrowthRank) / 10;

                    const earlyGames = playerHistory.slice(0, 3);
                    const lateGames = playerHistory.slice(-3);
                    const earlyWins = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] > earlyGames[i]).length;
                    const lateWins = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] > earlyGames[i]).length;
                    const earlyLosses = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] < earlyGames[i]).length;
                    const lateLosses = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] < earlyGames[i]).length;
                    const earlyWinRate = (earlyWins + earlyLosses) > 0 ? earlyWins / (earlyWins + earlyLosses) : 0;
                    const lateWinRate = (lateWins + lateLosses) > 0 ? lateWins / (lateWins + lateLosses) : 0;
                    player.winRateImprovement = lateWinRate - earlyWinRate;
                    const winRateImproveRank = getRank(player, 'winRateImprovement');
                    const winRateImproveScore = getPercentileScore(winRateImproveRank) / 10;

                    const earlyDominant = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i] >= 6 && earlyGames[i + 1] <= 1).length;
                    const lateDominant = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i] >= 6 && earlyGames[i + 1] <= 1).length;
                    const earlyDominantRate = earlyGames.length > 0 ? earlyDominant / (earlyGames.length / 2) : 0;
                    const lateDominantRate = lateGames.length > 0 ? lateDominant / (lateGames.length / 2) : 0;
                    player.dominantRateImprovement = lateDominantRate - earlyDominantRate;
                    const dominantImproveRank = getRank(player, 'dominantRateImprovement');
                    const dominantImproveScore = getPercentileScore(dominantImproveRank) / 10;

                    const improvedScore = ((mmrGrowthScore * 0.4) + (winRateImproveScore * 0.3) + (dominantImproveScore * 0.3)).toFixed(1);
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Î∞úÏ†ÑÏÉÅ Ï†êÏàò: ${improvedScore}`);
                    if (parseFloat(improvedScore) > maxImprovedScore) {
                        secondImprovedScore = maxImprovedScore;
                        improvedRunnerUp = mostImprovedPlayer;
                        maxImprovedScore = parseFloat(improvedScore);
                        mostImprovedPlayer = { name: player.name, value: improvedScore };
                    } else if (parseFloat(improvedScore) > secondImprovedScore && parseFloat(improvedScore) < maxImprovedScore) {
                        secondImprovedScore = parseFloat(improvedScore);
                        improvedRunnerUp = { name: player.name, value: improvedScore };
                    }

                    const courtKillerRank = getRank(player, 'gameDiffRate');
                    const courtKillerScore = getPercentileScore(courtKillerRank) / 10;
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏΩîÌä∏ ÌÇ¨Îü¨ Ï†êÏàò: ${courtKillerScore}`);
                    if (courtKillerScore > maxCourtKillerScore) {
                        secondCourtKillerScore = maxCourtKillerScore;
                        courtKillerRunnerUp = courtKillerPlayer;
                        maxCourtKillerScore = courtKillerScore;
                        courtKillerPlayer = { name: player.name, value: courtKillerScore.toFixed(1) };
                    } else if (courtKillerScore > secondCourtKillerScore && courtKillerScore < maxCourtKillerScore) {
                        secondCourtKillerScore = courtKillerScore;
                        courtKillerRunnerUp = { name: player.name, value: courtKillerScore.toFixed(1) };
                    }

                    // ÎèåÌíçÏÉÅ: MMR ÏÉÅÏäπÎ•† % (ÏµúÏÜå 3Í≤ΩÍ∏∞)
                    if (totalGamesPlayed >= 3) {
                        const stormerRate = player.mmrGrowthRate;
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÎèåÌíçÏÉÅ ÏÉÅÏäπÎ•†: ${stormerRate.toFixed(1)}%`);
                        if (stormerRate > maxStormerRate) {
                            secondStormerRate = maxStormerRate;
                            stormerRunnerUp = stormerPlayer;
                            maxStormerRate = stormerRate;
                            stormerPlayer = { name: player.name, value: stormerRate.toFixed(1) };
                        } else if (stormerRate > secondStormerRate && stormerRate < maxStormerRate) {
                            secondStormerRate = stormerRate;
                            stormerRunnerUp = { name: player.name, value: stormerRate.toFixed(1) };
                        }
                    }

                    // ÏßÄÎ∞∞ÏûêÏÉÅ: ÏïïÎèÑÏäπÎ•† % (ÏµúÏÜå 3Í≤ΩÍ∏∞)
                    if (totalGamesPlayed >= 3) {
                        const dominatorRate = totalGamesPlayed > 0 ? ((player.dominantWins || 0) / totalGamesPlayed * 100) : 0;
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÏßÄÎ∞∞ÏûêÏÉÅ ÏïïÎèÑÏäπÎ•†: ${dominatorRate.toFixed(1)}%`);
                        if (dominatorRate > maxDominatorRate) {
                            secondDominatorRate = maxDominatorRate;
                            dominatorRunnerUp = dominatorPlayer;
                            maxDominatorRate = dominatorRate;
                            dominatorPlayer = { name: player.name, value: `${dominatorRate.toFixed(1)}%` };
                        } else if (dominatorRate > secondDominatorRate && dominatorRate < maxDominatorRate) {
                            secondDominatorRate = dominatorRate;
                            dominatorRunnerUp = { name: player.name, value: `${dominatorRate.toFixed(1)}%` };
                        }
                    }

                    // ÎåÄÌòàÏ†ÑÏÉÅ: Ï†ëÏ†ÑÎ•† % (ÏµúÏÜå 3Í≤ΩÍ∏∞)
                    if (totalGamesPlayed >= 3) {
                        const closeMatchCount = closeMatches[player.name] || 0;
                        const closeMatchRate = totalGamesPlayed > 0 ? (closeMatchCount / totalGamesPlayed * 100) : 0;
                        const avgGameDiff = totalGamesPlayed > 0 ? (player.gameDiff || 0) / totalGamesPlayed : 0;
                        console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} ÎåÄÌòàÏ†ÑÏÉÅ Ï†ëÏ†ÑÎ•†: ${closeMatchRate.toFixed(1)}%, ÌèâÍ∑† Í≤åÏûÑ ÎìùÏã§: ${avgGameDiff.toFixed(2)}`);
                        if (closeMatchRate > maxCloseMatchRate || (closeMatchRate === maxCloseMatchRate && avgGameDiff < (epicBattlePlayer?.avgGameDiff || Infinity))) {
                            secondCloseMatchRate = maxCloseMatchRate;
                            epicBattleRunnerUp = epicBattlePlayer;
                            maxCloseMatchRate = closeMatchRate;
                            epicBattlePlayer = { name: player.name, value: closeMatchRate.toFixed(1), avgGameDiff };
                        } else if (closeMatchRate > secondCloseMatchRate || (closeMatchRate === secondCloseMatchRate && avgGameDiff < (epicBattleRunnerUp?.avgGameDiff || Infinity))) {
                            secondCloseMatchRate = closeMatchRate;
                            epicBattleRunnerUp = { name: player.name, value: closeMatchRate.toFixed(1), avgGameDiff };
                        }
                    }

                    let streakCount = 0;
                    let maxStreak = 0;
                    playerHistory.forEach((_, i) => {
                        if (i % 2 === 0 && playerHistory[i + 1] > playerHistory[i]) {
                            streakCount++;
                            maxStreak = Math.max(maxStreak, streakCount);
                        } else {
                            streakCount = 0;
                        }
                    });
                    const formScore = totalGamesPlayed > 0 ? ((maxStreak + (player.dominantWins || 0)) * normFactor / totalGamesPlayed) : 0;
                    console.log(`ÌîåÎ†àÏù¥Ïñ¥ ${player.name} Ìèº 1ÏúÑ Ï†êÏàò: ${formScore}`);
                    if (formScore > maxFormScore) {
                        maxFormScore = formScore;
                        formKing = { name: player.name, value: formScore.toFixed(2) };
                    }
                });

                for (const key in rivalries) {
                    const rivalry = rivalries[key];
                    if (rivalry.games >= 2) {
                        const diff = Math.abs(rivalry.wins1 - rivalry.wins2);
                        console.log(`ÎùºÏù¥Î≤å ${rivalry.player1}-${rivalry.player2} Ï∞®Ïù¥: ${diff}`);
                        if (diff < minRivalDiff) {
                            minRivalDiff = diff;
                            rivalPair = { name: `${rivalry.player1} vs ${rivalry.player2}`, value: diff };
                        }
                    }
                }

                try {
                    const awardsToSave = {
                        mvpMale: { winner: mvpMalePlayer || { name: '-', value: '-' }, runnerUp: mvpMaleRunnerUp || { name: '-', value: '-' } },
                        mvpFemale: { winner: mvpFemalePlayer || { name: '-', value: '-' }, runnerUp: mvpFemaleRunnerUp || { name: '-', value: '-' } },
                        mostImproved: { winner: mostImprovedPlayer || { name: '-', value: '-' }, runnerUp: improvedRunnerUp || { name: '-', value: '-' } },
                        courtKiller: { winner: courtKillerPlayer || { name: '-', value: '-' }, runnerUp: courtKillerRunnerUp || { name: '-', value: '-' } },
                        stormer: { winner: stormerPlayer || { name: '-', value: '-' }, runnerUp: stormerRunnerUp || { name: '-', value: '-' } },
                        dominator: { winner: dominatorPlayer || { name: '-', value: '-' }, runnerUp: dominatorRunnerUp || { name: '-', value: '-' } },
                        epicBattle: { winner: epicBattlePlayer || { name: '-', value: '-' }, runnerUp: epicBattleRunnerUp || { name: '-', value: '-' } },
                        rivalPair: { winner: rivalPair || { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } },
                        formKing: { winner: formKing || { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } }
                    };
                    console.log("Ï†ÄÏû•Ìï† Ïñ¥ÏõåÎìú Îç∞Ïù¥ÌÑ∞:", awardsToSave);
                    await setDoc(doc(db, 'league', 'data', 'awards', 'v1'), awardsToSave, { merge: true });
                    console.log("Ïñ¥ÏõåÎìú Ï†ÄÏû• ÏôÑÎ£å!");
                } catch (error) {
                    console.error("Ïñ¥ÏõåÎìú Ï†ÄÏû• Ïã§Ìå®:", error.message);
                    showToast("Ïñ¥ÏõåÎìú Ï†ÄÏû• Ïã§Ìå®! Ïû¨ÏãúÎèÑ Ï§ë...");
                    setTimeout(async () => {
                        try {
                            await setDoc(doc(db, 'league', 'data', 'awards', 'v1'), {
                                mvpMale: { winner: mvpMalePlayer || { name: '-', value: '-' }, runnerUp: mvpMaleRunnerUp || { name: '-', value: '-' } },
                                mvpFemale: { winner: mvpFemalePlayer || { name: '-', value: '-' }, runnerUp: mvpFemaleRunnerUp || { name: '-', value: '-' } },
                                mostImproved: { winner: mostImprovedPlayer || { name: '-', value: '-' }, runnerUp: improvedRunnerUp || { name: '-', value: '-' } },
                                courtKiller: { winner: courtKillerPlayer || { name: '-', value: '-' }, runnerUp: courtKillerRunnerUp || { name: '-', value: '-' } },
                                stormer: { winner: stormerPlayer || { name: '-', value: '-' }, runnerUp: stormerRunnerUp || { name: '-', value: '-' } },
                                dominator: { winner: dominatorPlayer || { name: '-', value: '-' }, runnerUp: dominatorRunnerUp || { name: '-', value: '-' } },
                                epicBattle: { winner: epicBattlePlayer || { name: '-', value: '-' }, runnerUp: epicBattleRunnerUp || { name: '-', value: '-' } },
                                rivalPair: { winner: rivalPair || { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } },
                                formKing: { winner: formKing || { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } }
                            }, { merge: true });
                            console.log("Ïñ¥ÏõåÎìú Ïû¨ÏãúÎèÑ Ï†ÄÏû• ÏôÑÎ£å!");
                        } catch (retryError) {
                            console.error("Ïñ¥ÏõåÎìú Ïû¨ÏãúÎèÑ Ïã§Ìå®:", retryError.message);
                            showToast("Ïñ¥ÏõåÎìú Ï†ÄÏû• ÏµúÏ¢Ö Ïã§Ìå®!");
                        }
                    }, 1000);
                }
            } else {
                console.warn("Í≤ΩÍ∏∞Ìïú ÌîåÎ†àÏù¥Ïñ¥ ÏóÜÏùå!");
                showToast("Ïñ¥ÏõåÎìú Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
            }
        } else {
            console.warn("ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå!");
            showToast("Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        const top5PlayerNames = allPlayersData.slice(0, 5).map(p => p.name);
        console.log("TOP 5 ÌîåÎ†àÏù¥Ïñ¥:", top5PlayerNames);

        if (top5PlayerNames.length > 0) {
            const useWinRate = fullMmrHistory.length === 0;
            renderMmrChart(fullMmrHistory, top5PlayerNames, useWinRate);
        } else {
            showToast("TOP 5 ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        if (allPlayersData.length > 0) {
            setupPlayerSelector();
            renderPlayerRadarChart(allPlayersData[0].name);
        } else {
            showToast("Î†àÏù¥Îçî Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±!");
        }

        const awardDetails = {
            mvpMale: { title: "ÏãúÏ¶å MVP (ÎÇ®)", icon: "üëë" },
            mvpFemale: { title: "ÏãúÏ¶å MVP (Ïó¨)", icon: "üëë" },
            mostImproved: { title: "ÏãúÏ¶å Î∞úÏ†ÑÏÉÅ", icon: "üöÄ" },
            courtKiller: { title: "ÏãúÏ¶å ÏΩîÌä∏ÌÇ¨Îü¨", icon: "üí£" },
            stormer: { title: "ÏãúÏ¶å ÎèåÌíçÏÉÅ", icon: "üå™Ô∏è" },
            dominator: { title: "ÏãúÏ¶å ÏßÄÎ∞∞ÏûêÏÉÅ", icon: "‚ö°" },
            epicBattle: { title: "ÏãúÏ¶å ÎåÄÌòàÏ†ÑÏÉÅ", icon: "üó°Ô∏è" },
            rivalPair: { title: "ÏãúÏ¶å ÎùºÏù¥Î≤å", icon: "‚öîÔ∏è" },
            formKing: { title: "ÏãúÏ¶å Ìèº 1ÏúÑ", icon: "üî•" }
        };

        const grid = document.querySelector('.awards-grid');
        if (!grid) {
            console.error("awards-grid ÏöîÏÜå ÏóÜÏùå!");
            showToast("Ïñ¥ÏõåÎìú Í∑∏Î¶¨Îìú Ïò§Î•ò!");
            return;
        }
        grid.innerHTML = '';

        for (const key in awardDetails) {
            const awardInfo = awardDetails[key];
            const data = awardsData[key] || { winner: { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } };
            const winner = data.winner?.name || data.name || '-';
            const winnerValue = data.winner?.value || data.value || '-';
            const runnerUp = data.runnerUp?.name || '-';
            const runnerUpValue = data.runnerUp?.value || '-';

            console.log(`Ïñ¥ÏõåÎìú Î†åÎçîÎßÅ - ${awardInfo.title}: winner=${winner}, value=${winnerValue}, runnerUp=${runnerUp}, runnerUpValue=${runnerUpValue}`);

            const card = document.createElement('div');
            card.className = 'award-card';
            card.innerHTML = `
                <div class="award-icon">${awardInfo.icon}</div>
                <div class="award-title">${awardInfo.title}</div>
                <div class="award-winner">${winner}</div>
                <div class="award-value">${key === 'dominator' ? 'ÏäπÎ•†' : 'Ï†êÏàò'}: ${winnerValue}</div>
                <div class="award-runner-up">2ÏúÑ: ${runnerUp} (${key === 'dominator' ? 'ÏäπÎ•†' : 'Ï†êÏàò'}: ${runnerUpValue})</div>
            `;
            grid.appendChild(card);
        }
        console.log("Ïñ¥ÏõåÎìú Í∑∏Î¶¨Îìú Î†åÎçîÎßÅ ÏôÑÎ£å!");
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded Ïù¥Î≤§Ìä∏ Î∞úÏÉù");
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        } else {
            console.warn("theme-toggle ÏöîÏÜå ÏóÜÏùå!");
        }
        
        loadDashboard();

        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
            });
        }
    });
</script>
</body>
</html>