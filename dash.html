<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>2025 호수오픈 대시보드</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root{--bg:#121212;--surface:#1E1E1E;--primary:#4CAF50;--primary-variant:#81C784;--text:#E0E0E0;--text-sec:#A0A0A0;--gold:#FFD700;--border:#333;--shadow:rgba(0,0,0,0.5)}
        [data-theme="light"]{--bg:#F0F4F8;--surface:#FFF;--primary:#1A3C34;--primary-variant:#2A6B5B;--text:#1F2937;--text-sec:#6B7280;--border:#E5E7EB;--shadow:rgba(0,0,0,0.1)}
        body{font-family:'Noto Sans KR',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px}
        .container{max-width:960px;margin:auto}
        h1{font-family:'Poppins',sans-serif;font-size:2.8rem;text-align:center;color:transparent;background:linear-gradient(135deg,var(--primary),var(--primary-variant));-webkit-background-clip:text;background-clip:text;padding:20px 0;margin-bottom:3rem}
        .section{background:var(--surface);padding:30px;border-radius:16px;box-shadow:0 10px 30px var(--shadow);margin-bottom:3rem;border:1px solid var(--border)}
        h2{font-family:'Poppins',sans-serif;font-size:2.2rem;color:var(--primary);margin-bottom:20px;border-bottom:2px solid var(--border)}
        .charts-container{display:grid;gap:40px}
        .chart-control{margin-bottom:20px;text-align:center}
        .chart-control label{font-weight:700;margin-right:10px}
        .chart-control select{padding:8px;border-radius:6px;border:1px solid var(--border);background:var(--surface);color:var(--text);width:200px}
        .chart-control button{padding:8px 16px;border-radius:6px;border:1px solid var(--border);background:linear-gradient(135deg,var(--primary),var(--primary-variant));color:#FFF;cursor:pointer}
        .awards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:20px}
        .award-card{background:rgba(255,255,255,0.05);border:1px solid var(--border);border-radius:12px;padding:20px;text-align:center}
        [data-theme="light"] .award-card{background:#F9FAFB}
        .award-icon{font-size:3rem;margin-bottom:10px;color:var(--gold)}
        .award-title{font-family:'Poppins',sans-serif;font-size:1.3rem;color:var(--primary-variant);margin-bottom:5px}
        .award-winner{font-size:1.1rem;font-weight:700;color:var(--text)}
        .award-value{font-size:0.9rem;color:var(--text-sec)}
        .award-runner-up{font-size:0.9rem;color:var(--text-sec);margin-top:5px}
        .btn{display:inline-block;padding:12px 28px;margin:10px;background:linear-gradient(135deg,var(--primary),var(--primary-variant));color:#FFF;text-decoration:none;border-radius:8px;font-weight:700}
        [data-theme="dark"] .btn{color:var(--bg)}
        .theme-toggle{position:fixed;top:20px;right:20px;background:var(--surface);border:1px solid var(--border);border-radius:50%;width:40px;height:40px;font-size:1.5rem;cursor:pointer;color:var(--text);display:flex;justify-content:center;align-items:center}
        .toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#333,#111);color:#fff;padding:12px 25px;border-radius:50px;box-shadow:0 5px 15px var(--shadow);opacity:0;transition:opacity 0.4s;font-weight:700}
        [data-theme="light"] .toast{background:linear-gradient(135deg,#f9f9f9,#f1f1f1);color:#333}
        .toast.show{opacity:1}
        #mmr-chart-container canvas{height:40vh;width:100%;max-height:400px}
        .season-tabs{display:flex;gap:10px;margin-bottom:20px;border-bottom:2px solid var(--border);padding-bottom:10px}
        .tab-btn{padding:10px 20px;font-size:1rem;font-weight:700;background:none;border:none;color:var(--text-sec);cursor:pointer;border-bottom:3px solid transparent;transition:color .3s,border-color .3s}
        .tab-btn.active{color:var(--primary);border-bottom:3px solid var(--primary)}
        @media (max-width:640px){
            body{padding:10px}
            h1{font-size:2.2rem}
            h2{font-size:1.8rem}
            .section{padding:20px}
            .awards-grid{grid-template-columns:1fr}
            .tab-btn{padding:8px 10px;font-size:.9rem}
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1 id="main-title">2025-26 겨울시즌 대시보드</h1>
        <div class="season-tabs">
            <button class="tab-btn active" data-view="current">2025-26 겨울 시즌</button>
            <button class="tab-btn" data-view="previous">2025 여름시즌</button>
            <button class="tab-btn" data-view="alltime">통산 기록</button>
        </div>
        <div class="section">
            <h2>통계 차트</h2>
            <div class="charts-container">
                <div id="mmr-chart-container">
                    <h3 id="mmr-chart-title">MMR 히스토리 (최근 2개월)</h3>
                    <div class="chart-control">
                        <label for="mmr-player-select">선수 선택:</label>
                        <select id="mmr-player-select" multiple size="5"></select>
                        <button id="reset-mmr-chart">초기화</button>
                    </div>
                    <canvas id="mmr-chart"></canvas>
                </div>
            </div>
        </div>
        <div class="section">
            <h2 id="awards-title">🏆 2025-26 겨울시즌 어워드</h2>
            <div class="awards-grid"></div>
            <div style="text-align:center;margin-top:30px">
                <a href="index.html" class="btn" id="main-link">메인으로 돌아가기</a>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAlcszFYMqJjaJQHajx7K695zoeRS7PsxU",
            authDomain: "tennis-plan-jibung.firebaseapp.com",
            projectId: "tennis-plan-jibung",
            storageBucket: "tennis-plan-jibung.appspot.com",
            messagingSenderId: "491083537160",
            appId: "1:491083537160:web:0c2ec53b1285aa1cdc6abd"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        const BASE_COLLECTION = 'league';
        const SEASONS = {
            'v2': { name: '2025-26 겨울 시즌' },
            'v1': { name: '2025 여름시즌' },
        };
        const CURRENT_SEASON_VERSION = 'v2';
        const PREVIOUS_SEASON_VERSION = 'v1';

        let mmrChart, allPlayersData = [], fullMmrHistory = [];
        let activeView = 'current';

        const normalizePlayerName = name => name ? name.replace(/\*/g, '').trim() : '';
        const totalGames = player => parseInt(player.wins || 0) + parseInt(player.losses || 0);

        const setupMmrPlayerSelector = (players) => {
            const select = document.getElementById('mmr-player-select');
            const playedPlayers = players.filter(p => totalGames(p) > 0).sort((a,b) => a.name.localeCompare(b.name, 'ko'));
            select.innerHTML = playedPlayers.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        };
        
        const getJsDate = (firestoreTimestamp) => {
            if (!firestoreTimestamp) return null;
            if (typeof firestoreTimestamp.toDate === 'function') return firestoreTimestamp.toDate();
            return new Date(firestoreTimestamp);
        };

        const renderMmrChart = (history, selectedPlayers, timeRangeMonths = 2) => {
            const ctx = document.getElementById('mmr-chart')?.getContext('2d');
            if (!ctx) return;
            
            if (mmrChart) mmrChart.destroy();
            mmrChart = null;

            if (!selectedPlayers || selectedPlayers.length === 0 || history.length === 0) return;

            const endDate = new Date();
            const startDate = new Date();
            startDate.setMonth(endDate.getMonth() - timeRangeMonths);

            const dateLabels = [];
            if (timeRangeMonths === 12) {
                for (let i = 0; i <= 12; i++) {
                    const d = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
                    if (d <= endDate) {
                        dateLabels.push(d);
                    }
                }
                if(dateLabels.length > 0 && dateLabels[dateLabels.length - 1].getTime() < endDate.getTime()){
                     dateLabels.push(endDate);
                }
            } else {
                const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
                for (let d = new Date(startDate); d <= endDate; d.setTime(d.getTime() + SEVEN_DAYS_MS)) {
                    dateLabels.push(new Date(d));
                }
                if (dateLabels.length === 0 || dateLabels[dateLabels.length - 1].getTime() < endDate.getTime()) {
                    dateLabels.push(endDate);
                }
            }

            const datasets = selectedPlayers.map((name, i) => {
                const cleanName = normalizePlayerName(name).replace(/\./g, '_');
                const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
                
                const data = dateLabels.map(targetDate => {
                    const snapshotsBefore = history
                        .filter(h => h.createdAt && getJsDate(h.createdAt) <= targetDate && h[cleanName] !== undefined);
                    
                    if (snapshotsBefore.length > 0) {
                        return snapshotsBefore[snapshotsBefore.length - 1][cleanName];
                    }
                    return null;
                });

                return {
                    label: name, data,
                    borderColor: colors[i % colors.length],
                    fill: false, tension: 0.3, pointRadius: 5, pointHoverRadius: 8, borderWidth: 3, spanGaps: true 
                };
            });

            const mmrValues = datasets.flatMap(ds => ds.data).filter(v => v !== null);
            const minMMR = mmrValues.length ? Math.floor(Math.min(...mmrValues) / 50) * 50 - 50 : 1400;
            const maxMMR = mmrValues.length ? Math.ceil(Math.max(...mmrValues) / 50) * 50 + 50 : 1800;
            
            const displayLabels = dateLabels.map(d => {
                if (timeRangeMonths === 12) {
                    return d.toLocaleDateString('ko-KR', { year: '2-digit', month: 'long' });
                }
                return d.toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });
            });

            mmrChart = new Chart(ctx, {
                type: 'line',
                data: { labels: displayLabels, datasets },
                options: {
                    scales: {
                        x: { ticks: { color: 'var(--text-sec)'}, grid: { color: 'var(--border)' } },
                        y: { ticks: { color: 'var(--text-sec)'}, grid: { color: 'var(--border)' }, min: minMMR, max: maxMMR }
                    },
                    plugins: { legend: { labels: { color: 'var(--text)' } } },
                    maintainAspectRatio: false,
                    responsive: true
                }
            });
        };

        const showToast = msg => {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        };

        const applyTheme = theme => {
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('theme-toggle').textContent = theme === 'dark' ? '☀️' : '🌙';
            localStorage.setItem('theme', theme);
            if (mmrChart) {
                const selectedPlayers = Array.from(document.getElementById('mmr-player-select').selectedOptions).map(opt => opt.value);
                const timeRange = activeView === 'alltime' ? 12 : 2;
                renderMmrChart(fullMmrHistory, selectedPlayers, timeRange);
            }
        };
        
        const calculateAndRenderAwards = (players, history, matches, view) => {
            const playedPlayers = players.filter(p => totalGames(p) > 0);
            const awardsGrid = document.querySelector('.awards-grid');
            awardsGrid.innerHTML = '';
            if (playedPlayers.length === 0) return;

            let awards = {
                mvpMale: { winner: null, runnerUp: null },
                mvpFemale: { winner: null, runnerUp: null },
                mostImproved: { winner: null, runnerUp: null, maxScore: -Infinity },
                dominantForce: { winner: null, runnerUp: null, maxScore: -Infinity },
                winKing: { winner: null, runnerUp: null, maxScore: -Infinity },
                playerOfMonth: { winner: null, runnerUp: null, maxScore: -Infinity },
                peakMmr: { winner: null, runnerUp: null, maxScore: -Infinity },
                ironMental: { winner: null, runnerUp: null, maxScore: -Infinity },
                bestChemistry: { winner: null, runnerUp: null, maxScore: -Infinity },
                ironMan: { winner: null, runnerUp: null, maxScore: -Infinity }
            };

            const clutchStats = {};
            const chemistryStats = {};

            matches.forEach(match => {
                if (!match.score || !match.players || match.players.length < 4) return;
                const [score1, score2] = match.score.split('-').map(Number);
                const winners = score1 > score2 ? [match.players[0], match.players[1]] : [match.players[2], match.players[3]];
                const losers = score1 > score2 ? [match.players[2], match.players[3]] : [match.players[0], match.players[1]];
                
                if (Math.abs(score1 - score2) <= 2) {
                    [...winners, ...losers].forEach((p, index) => {
                        const name = normalizePlayerName(p);
                        if (!clutchStats[name]) clutchStats[name] = { wins: 0, total: 0 };
                        if (index < 2) clutchStats[name].wins++;
                        clutchStats[name].total++;
                    });
                }
                
                const cleanWinners = winners.map(normalizePlayerName);
                if (!chemistryStats[cleanWinners[0]]) chemistryStats[cleanWinners[0]] = new Set();
                chemistryStats[cleanWinners[0]].add(cleanWinners[1]);
                if (!chemistryStats[cleanWinners[1]]) chemistryStats[cleanWinners[1]] = new Set();
                chemistryStats[cleanWinners[1]].add(cleanWinners[0]);
            });
            
            const maleMvpCandidates = playedPlayers.filter(p => !p.isFemale).sort((a,b) => (b.mmr || 0) - (a.mmr || 0));
            if (maleMvpCandidates.length > 0) awards.mvpMale.winner = { name: maleMvpCandidates[0].name, value: `${Math.round(maleMvpCandidates[0].mmr)}점` + (view === 'alltime' ? ' (Peak)' : '') };
            if (maleMvpCandidates.length > 1) awards.mvpMale.runnerUp = { name: maleMvpCandidates[1].name, value: `${Math.round(maleMvpCandidates[1].mmr)}점` + (view === 'alltime' ? ' (Peak)' : '') };
            
            const femaleMvpCandidates = playedPlayers.filter(p => p.isFemale).sort((a,b) => (b.mmr || 0) - (a.mmr || 0));
            if (femaleMvpCandidates.length > 0) awards.mvpFemale.winner = { name: femaleMvpCandidates[0].name, value: `${Math.round(femaleMvpCandidates[0].mmr)}점` + (view === 'alltime' ? ' (Peak)' : '') };
            if (femaleMvpCandidates.length > 1) awards.mvpFemale.runnerUp = { name: femaleMvpCandidates[1].name, value: `${Math.round(femaleMvpCandidates[1].mmr)}점` + (view === 'alltime' ? ' (Peak)' : '') };

            playedPlayers.forEach(player => {
                const cleanPlayerName = normalizePlayerName(player.name);
                
                const winDiff = (player.wins || 0) - (player.losses || 0);
                if (winDiff > awards.winKing.maxScore) {
                    awards.winKing.runnerUp = awards.winKing.winner;
                    awards.winKing.maxScore = winDiff;
                    awards.winKing.winner = { name: player.name, value: `${player.wins}승 ${player.losses}패 (승차: ${winDiff})`, score: winDiff };
                } else if (winDiff > (awards.winKing.runnerUp?.score || -Infinity)) {
                    awards.winKing.runnerUp = { name: player.name, value: `${player.wins}승 ${player.losses}패 (승차: ${winDiff})`, score: winDiff };
                }

                if(view !== 'alltime') {
                    const thirtyDaysAgo = new Date();
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    const recentMatches = matches.filter(m => new Date(m.timestamp) > thirtyDaysAgo && m.players.map(p => normalizePlayerName(p)).includes(cleanPlayerName));
                    
                    if (recentMatches.length >= 3) {
                        const recentWins = recentMatches.filter(m => {
                            const [s1, s2] = m.score.split('-').map(Number);
                            const winners = s1 > s2 ? [m.players[0], m.players[1]] : [m.players[2], m.players[3]];
                            return winners.map(p => normalizePlayerName(p)).includes(cleanPlayerName);
                        }).length;

                        const historyInPeriod = history.filter(h => getJsDate(h.createdAt) > thirtyDaysAgo);
                        let startMmr = player.mmr;
                        
                        const playerHistoryKey = cleanPlayerName.replace(/\./g, '_');
                        const firstSnapInPeriod = historyInPeriod.find(h => h[playerHistoryKey] !== undefined);
                        if (firstSnapInPeriod) {
                            startMmr = firstSnapInPeriod[playerHistoryKey];
                        }
                        
                        const mmrIncrease = player.mmr - startMmr;
                        const pomScore = mmrIncrease + (recentWins * 10);

                        if (pomScore > awards.playerOfMonth.maxScore) {
                            awards.playerOfMonth.runnerUp = awards.playerOfMonth.winner;
                            awards.playerOfMonth.maxScore = pomScore;
                            awards.playerOfMonth.winner = { name: player.name, value: `+${Math.round(mmrIncrease)}점, 최근 ${recentWins}승`, score: pomScore };
                        } else if (pomScore > (awards.playerOfMonth.runnerUp?.score || -Infinity)) {
                            awards.playerOfMonth.runnerUp = { name: player.name, value: `+${Math.round(mmrIncrease)}점, 최근 ${recentWins}승`, score: pomScore };
                        }
                    }
                }

                const playerHistory = history.map(h => ({ mmr: h[cleanPlayerName.replace(/\./g, '_')], date: getJsDate(h.createdAt) })).filter(e => e.mmr);
                if (playerHistory.length >= 2) {
                    const firstMmr = playerHistory[0].mmr;
                    const mmrGrowth = player.mmr - firstMmr;
                    if (mmrGrowth > awards.mostImproved.maxScore) {
                        awards.mostImproved.runnerUp = awards.mostImproved.winner;
                        awards.mostImproved.maxScore = mmrGrowth;
                        awards.mostImproved.winner = { name: player.name, value: `+${Math.round(mmrGrowth)}점`, score: mmrGrowth };
                    } else if (mmrGrowth > (awards.mostImproved.runnerUp?.score || -Infinity)) {
                        awards.mostImproved.runnerUp = { name: player.name, value: `+${Math.round(mmrGrowth)}점`, score: mmrGrowth };
                    }
                }
                const dominantWinCount = parseInt((player.dominantWins || "0%(0)").match(/\((\d+)/)?.[1] || '0');
                if (totalGames(player) >= 10) {
                    const dominantScore = (dominantWinCount / totalGames(player) * 50) + (parseFloat(player.avgGameDiff) * 5);
                    if (dominantScore > awards.dominantForce.maxScore) {
                        awards.dominantForce.runnerUp = awards.dominantForce.winner;
                        awards.dominantForce.maxScore = dominantScore;
                        awards.dominantForce.winner = { name: player.name, value: `압도승률 ${((dominantWinCount/totalGames(player))*100).toFixed(0)}%`, score: dominantScore };
                    } else if (dominantScore > (awards.dominantForce.runnerUp?.score || -Infinity)) {
                        awards.dominantForce.runnerUp = { name: player.name, value: `압도승률 ${((dominantWinCount/totalGames(player))*100).toFixed(0)}%`, score: dominantScore };
                    }
                }
                const peakMmr = Math.max(...playerHistory.map(h => h.mmr), player.mmr);
                if (peakMmr > awards.peakMmr.maxScore) {
                    awards.peakMmr.runnerUp = awards.peakMmr.winner;
                    awards.peakMmr.maxScore = peakMmr;
                    awards.peakMmr.winner = { name: player.name, value: `${Math.round(peakMmr)}점`, score: peakMmr };
                } else if (peakMmr > (awards.peakMmr.runnerUp?.score || -Infinity)) {
                    awards.peakMmr.runnerUp = { name: player.name, value: `${Math.round(peakMmr)}점`, score: peakMmr };
                }
                if (clutchStats[cleanPlayerName] && clutchStats[cleanPlayerName].total >= 5) {
                    const clutchRate = clutchStats[cleanPlayerName].wins / clutchStats[cleanPlayerName].total;
                    if (clutchRate > awards.ironMental.maxScore) {
                        awards.ironMental.runnerUp = awards.ironMental.winner;
                        awards.ironMental.maxScore = clutchRate;
                        awards.ironMental.winner = { name: player.name, value: `접전 승률 ${(clutchRate * 100).toFixed(0)}%`, score: clutchRate };
                    } else if (clutchRate > (awards.ironMental.runnerUp?.score || -Infinity)) {
                        awards.ironMental.runnerUp = { name: player.name, value: `접전 승률 ${(clutchRate * 100).toFixed(0)}%`, score: clutchRate };
                    }
                }
                const chemistryCount = chemistryStats[cleanPlayerName]?.size || 0;
                if (chemistryCount > awards.bestChemistry.maxScore) {
                    awards.bestChemistry.runnerUp = awards.bestChemistry.winner;
                    awards.bestChemistry.maxScore = chemistryCount;
                    awards.bestChemistry.winner = { name: player.name, value: `${chemistryCount}명과 승리`, score: chemistryCount };
                } else if (chemistryCount > (awards.bestChemistry.runnerUp?.score || -Infinity)) {
                    awards.bestChemistry.runnerUp = { name: player.name, value: `${chemistryCount}명과 승리`, score: chemistryCount };
                }
                if (totalGames(player) > awards.ironMan.maxScore) {
                    awards.ironMan.runnerUp = awards.ironMan.winner;
                    awards.ironMan.maxScore = totalGames(player);
                    awards.ironMan.winner = { name: player.name, value: `${totalGames(player)}경기`, score: totalGames(player) };
                } else if (totalGames(player) > (awards.ironMan.runnerUp?.score || -Infinity)) {
                    awards.ironMan.runnerUp = { name: player.name, value: `${totalGames(player)}경기`, score: totalGames(player) };
                }
            });


            const awardDetails = view === 'alltime' ? {
                mvpMale: { title: "통산 MVP (남)", icon: "👑" },
                mvpFemale: { title: "통산 MVP (여)", icon: "👑" },
                mostImproved: { title: "통산 발전상", icon: "🚀" },
                dominantForce: { title: "압도적 포스", icon: "💣" },
                winKing: { title: "통산 다승왕", icon: "🏆" },
                peakMmr: { title: "역대 최고점", icon: "📈" },
                ironMental: { title: "강철 멘탈", icon: "🧠" },
                bestChemistry: { title: "케미 요정", icon: "🤝" },
                ironMan: { title: "철인상 (최다 출전)", icon: "🏃" }
            } : {
                mvpMale: { title: "시즌 MVP (남)", icon: "👑" },
                mvpFemale: { title: "시즌 MVP (여)", icon: "👑" },
                mostImproved: { title: "시즌 발전상", icon: "🚀" },
                dominantForce: { title: "압도적 포스", icon: "💣" },
                winKing: { title: "시즌 다승왕", icon: "🏆" },
                playerOfMonth: { title: "이달의 선수", icon: "🌟" },
                peakMmr: { title: "시즌 최고점", icon: "📈" },
                ironMental: { title: "강철 멘탈", icon: "🧠" },
                bestChemistry: { title: "케미 요정", icon: "🤝" },
                ironMan: { title: "철인상 (최다 출전)", icon: "🏃" }
            };

            for (const key in awardDetails) {
                const data = awards[key];
                if (!data.winner) continue;
                
                const card = document.createElement('div');
                card.className = 'award-card';
                card.innerHTML = `
                    <div class="award-icon">${awardDetails[key].icon}</div>
                    <div class="award-title">${awardDetails[key].title}</div>
                    <div class="award-winner">${data.winner.name}</div>
                    <div class="award-value">${data.winner.value}</div>
                    ${data.runnerUp ? `<div class="award-runner-up">2위: ${data.runnerUp.name} (${data.runnerUp.value})</div>` : ''}
                `;
                awardsGrid.appendChild(card);
            }
        };

        const loadDashboard = async () => {
            showToast('데이터를 불러오는 중입니다...');
            try {
                let seasonVersion = CURRENT_SEASON_VERSION;
                if (activeView === 'previous') seasonVersion = PREVIOUS_SEASON_VERSION;
                
                if (activeView === 'alltime') {
                    document.getElementById('main-title').textContent = '통산 기록 대시보드';
                    document.getElementById('awards-title').textContent = '🏆 통산 기록 어워드';
                    document.getElementById('mmr-chart-title').textContent = 'MMR 히스토리 (최근 1년)';
                    
                    const [rankingsV1, rankingsV2, scheduleV1, scheduleV2, historyV1Snap, historyV2Snap] = await Promise.all([
                        getDoc(doc(db, BASE_COLLECTION, 'data', 'rankings', 'v1')),
                        getDoc(doc(db, BASE_COLLECTION, 'data', 'rankings', 'v2')),
                        getDoc(doc(db, BASE_COLLECTION, 'data', 'schedule', 'v1')),
                        getDoc(doc(db, BASE_COLLECTION, 'data', 'schedule', 'v2')),
                        getDocs(query(collection(db, BASE_COLLECTION, 'data', `rankingHistory`), orderBy('createdAt', 'asc'))),
                        getDocs(query(collection(db, BASE_COLLECTION, 'data', `rankingHistory-v2`), orderBy('createdAt', 'asc')))
                    ]);

                    const playersV1 = rankingsV1.exists() ? rankingsV1.data().players : [];
                    const playersV2 = rankingsV2.exists() ? rankingsV2.data().players : [];
                    const matchesV1 = scheduleV1.exists() ? scheduleV1.data().matches : [];
                    const matchesV2 = scheduleV2.exists() ? scheduleV2.data().matches : [];
                    const historyDataV1 = historyV1Snap.docs.map(d => d.data());
                    const historyDataV2 = historyV2Snap.docs.map(d => d.data());
                    
                    const allMatches = [...matchesV1, ...matchesV2];
                    
                    const cumulativeStats = {};
                    allMatches.forEach(match => {
                        if (!match.score || !match.players || match.players.length < 4) return;
                        const [score1, score2] = match.score.split('-').map(Number);
                        const winners = (score1 > score2 ? match.players.slice(0, 2) : match.players.slice(2, 4)).map(p => normalizePlayerName(p));
                        const losers = (score1 > score2 ? match.players.slice(2, 4) : match.players.slice(0, 2)).map(p => normalizePlayerName(p));
                        
                        match.players.forEach(p => {
                            const name = normalizePlayerName(p);
                            if (name && !cumulativeStats[name]) {
                                cumulativeStats[name] = { name, wins: 0, losses: 0, isFemale: p.includes('*') };
                            }
                        });

                        winners.forEach(w => { if(w) cumulativeStats[w].wins++; });
                        losers.forEach(l => { if(l) cumulativeStats[l].losses++; });
                    });
                    
                    fullMmrHistory = [...historyDataV1, ...historyDataV2].sort((a,b) => getJsDate(a.createdAt) - getJsDate(b.createdAt));
                    
                    const peakMmrs = {};
                    fullMmrHistory.forEach(snapshot => {
                        Object.keys(snapshot).forEach(key => {
                            if (key !== 'createdAt') {
                                const playerName = key.replace(/_/g, '.');
                                const currentMmr = snapshot[key];
                                if (!peakMmrs[playerName] || currentMmr > peakMmrs[playerName]) {
                                    peakMmrs[playerName] = currentMmr;
                                }
                            }
                        });
                    });

                    allPlayersData = Object.values(cumulativeStats);
                    allPlayersData.forEach(p => {
                        p.mmr = peakMmrs[p.name] || 1500;
                    });

                    calculateAndRenderAwards(allPlayersData, fullMmrHistory, allMatches, 'alltime');
                    setupMmrPlayerSelector(allPlayersData);
                    
                } else {
                    document.getElementById('main-title').textContent = `${SEASONS[seasonVersion].name} 대시보드`;
                    document.getElementById('awards-title').textContent = `🏆 ${SEASONS[seasonVersion].name} 어워드`;
                    document.getElementById('mmr-chart-title').textContent = 'MMR 히스토리 (최근 2개월)';

                    const rankingsSnap = await getDoc(doc(db, BASE_COLLECTION, 'data', 'rankings', seasonVersion));
                    const scheduleSnap = await getDoc(doc(db, BASE_COLLECTION, 'data', 'schedule', seasonVersion));
                    
                    let historyCollectionSnap;
                    let historyPath = seasonVersion === 'v1' ? `rankingHistory` : `rankingHistory-${seasonVersion}`;
                    const historyQuery = query(collection(db, BASE_COLLECTION, 'data', historyPath), orderBy('createdAt', 'asc'));
                    historyCollectionSnap = await getDocs(historyQuery);
                    
                    if (!rankingsSnap.exists()) return showToast("랭킹 데이터 없음!");
                    
                    allPlayersData = rankingsSnap.data().players || [];
                    const scheduleMatches = scheduleSnap.exists() ? scheduleSnap.data().matches || [] : [];
                    fullMmrHistory = historyCollectionSnap.docs.map(d => d.data());
                    
                    calculateAndRenderAwards(allPlayersData, fullMmrHistory, scheduleMatches, activeView);
                    setupMmrPlayerSelector(allPlayersData);
                }

                if (fullMmrHistory.length > 0 && allPlayersData.length > 0) {
                    const topPlayers = [...allPlayersData]
                        .filter(p => totalGames(p) > 0)
                        .sort((a, b) => (b.mmr || 1500) - (a.mmr || 1500))
                        .slice(0, 3)
                        .map(p => p.name);
                    
                    const timeRange = activeView === 'alltime' ? 12 : 2;
                    renderMmrChart(fullMmrHistory, topPlayers, timeRange);
                }

            } catch (e) {
                console.error("대시보드 로드 실패:", e);
                showToast("데이터 로드 실패! 콘솔을 확인하세요.");
            }
        };

        document.addEventListener('DOMContentLoaded', async () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
            
            try {
                await signInAnonymously(auth);
                loadDashboard();
            } catch(e) {
                console.error("Auth failed", e);
                showToast("DB 인증 실패");
            }

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.tab-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    activeView = btn.dataset.view;
                    loadDashboard();
                });
            });

            document.getElementById('theme-toggle').addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
            
            document.getElementById('mmr-player-select').addEventListener('change', e => {
                const selectedPlayers = Array.from(e.target.selectedOptions).map(opt => opt.value);
                const timeRange = activeView === 'alltime' ? 12 : 2;
                renderMmrChart(fullMmrHistory, selectedPlayers, timeRange);
            });

            document.getElementById('reset-mmr-chart').addEventListener('click', () => {
                document.getElementById('mmr-player-select').selectedIndex = -1;
                if (mmrChart) {
                    mmrChart.destroy();
                    mmrChart = null;
                }
            });
        });
    </script>
</body>
</html>
